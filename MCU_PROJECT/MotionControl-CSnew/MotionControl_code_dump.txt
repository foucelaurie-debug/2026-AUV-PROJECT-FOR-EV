MotionControl-CSnew (STM32H743) code dump for external AI review.
Project role (from repo README): motion control board closes the loop on attitude/position, computes thrust for six propellers, and interfaces with IMU/DVL and depth sensor.
Notes: Vendor HAL/CMSIS live under Drivers/. Build artifacts under build/. This dump focuses on project logic and HAL setup.
==== Core/Inc/main.h ====
Description: Global includes and pin/peripheral definitions.
---- code begin ----
/* USER CODE BEGIN Header */
/**
 ******************************************************************************
 * @file           : main.h
 * @brief          : Header for main.c file.
 *                   This file contains the common defines of the application.
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */
/* USER CODE END Header */

/* Define to prevent recursive inclusion -------------------------------------*/
#ifndef __MAIN_H
#define __MAIN_H

#ifdef __cplusplus
extern "C" {
#endif

/* Includes ------------------------------------------------------------------*/
#include "stm32h7xx_hal.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
#include "autocontrol.h"

/* USER CODE END Includes */

/* Exported types ------------------------------------------------------------*/
/* USER CODE BEGIN ET */
typedef struct {
    uint8_t state[6];
    PositionalPID x;
    PositionalPID y;
    PositionalPID z;
    PositionalPID rx;
    PositionalPID ry;
    PositionalPID rz;
} RobotController;
/* USER CODE END ET */

/* Exported constants --------------------------------------------------------*/
/* USER CODE BEGIN EC */
extern CoordinateSystems robot;
extern RobotController robot_controller;

extern float openloop_thrust[6];

extern int led_motion;
extern int led_dataup;
extern int led_uart4;
extern int led_uart7;
/* USER CODE END EC */

/* Exported macro ------------------------------------------------------------*/
/* USER CODE BEGIN EM */

/* USER CODE END EM */

/* Exported functions prototypes ---------------------------------------------*/
void Error_Handler(void);

/* USER CODE BEGIN EFP */

/* USER CODE END EFP */

/* Private defines -----------------------------------------------------------*/

/* USER CODE BEGIN Private defines */

/* USER CODE END Private defines */

#ifdef __cplusplus
}
#endif

#endif /* __MAIN_H */
---- code end ----

==== Core/Src/main.c ====
Description: Main loop: IMU/DVL UART handling, depth sensing, PID controllers, thrust allocation, and PWM output to six motors plus LEDs.
---- code begin ----
/* USER CODE BEGIN Header */
/**
 ******************************************************************************
 * @file           : main.c
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */
/* USER CODE END Header */
/* Includes ------------------------------------------------------------------*/
#include "main.h"
#include "i2c.h"
#include "tim.h"
#include "usart.h"
#include "gpio.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
#include "motor.h"
#include "comm.h"
#include "thrust.h"
#include "ms5837.h"
#include "usart.h"
#include "filter.h"

#include "autocontrol.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */
#define thrust_mean_filter_length 20

/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */
/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/

/* USER CODE BEGIN PV */
CoordinateSystems robot;
CoordinateSystems target;

float Vx = 0, Vy = 0, Ry = 0, Tx = 0, Ty = 0, Tz = 0, Mx = 0, My = 0, Mz = 0;


CoordinateSystems robot_pos; // 真实的机器人

CoordinateSystems robot_im_pos;    // 假的水平的机器人,用于计算机器人水平位置误差
CoordinateSystems robot_im_spd;    // 速度空间中的机器人,用于计算机器人水平横移、前进速度
CoordinateSystems robot_im_thrust; // 推力空间中的的机器人,用于计算推力
CoordinateVector  required_thrust = {0, 0, 0, 0, 0, 0};


RobotController robot_controller;
float           openloop_thrust[6] = {0}; // 0~5 correspond x y z rx ry rz

MeanFilter meanfilter[6];

int led_motion   = 0;
int led_dataup   = 0;
int led_uart4    = 0;
int led_uart7    = 0;
int led_main     = 0;
int led_watchdog = 0;
int led_ms5837   = 0;

int threadmonitor_tim2  = 30;
int threadmonitor_tim3  = 30;
int threadmonitor_uart4 = 300;
int threadmonitor_uart7 = 300;

int start = 0;

uint8_t transbuf[159] = {0};

float measureddepth = 0;
float realdepth     = 0;
float startdepth    = 0;
float checkeddepth  = 0;

uint8_t led[2] = {0, 0};

/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
/* USER CODE BEGIN PFP */

/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */
/*
 * 函数�??????: HAL_TIM_PeriodElapsedCallback
 * 描述  : 定时器中断处�??????
 * 输入  : TIM_HandleTypeDef *htim 定时器地�??????
 * 输出  : /
 * 备注  : 用于处理数据
 */
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
    static float motorthrust[6]        = {0}; // 0~5 correspond motor0~5
    static float askedthrust[6]        = {0};
    static float motorthrust_filted[6] = {0};


    //  1号定时器中断
    //  频率 20hz
    if (htim == (&htim1))
    { // watch dog
        threadmonitor_tim2--;
        threadmonitor_tim3--;
        threadmonitor_uart4--;
        threadmonitor_uart7--;

        if (threadmonitor_tim2 <= 0)
        {
            __HAL_TIM_CLEAR_IT(&htim2, TIM_IT_UPDATE);
            HAL_TIM_Base_Start_IT(&htim2);
            threadmonitor_tim2 = 30;
        }
        if (threadmonitor_tim3 <= 0)
        {
            __HAL_TIM_CLEAR_IT(&htim3, TIM_IT_UPDATE);
            HAL_TIM_Base_Start_IT(&htim3);
            threadmonitor_tim3 = 30;
        }
        // if (threadmonitor_uart4 <= 0)
        // {
        //     HAL_UART_Receive_IT(&huart4, uart4rec.buf, 1);
        //     __HAL_UART_CLEAR_OREFLAG(&huart4);
        //     threadmonitor_uart4 = 30;
        // }
        if (threadmonitor_uart7 <= 0)
        {
            MX_UART7_Init();
            HAL_UART_Receive_IT(&huart7, uart7rec.buf + uart7rec.cnt, 1);
            threadmonitor_uart7 = 50;
        }
        // led
        if (led_watchdog)
            HAL_GPIO_WritePin(GPIOD, GPIO_PIN_5, GPIO_PIN_SET);
        else
            HAL_GPIO_WritePin(GPIOD, GPIO_PIN_5, GPIO_PIN_RESET);
        led_watchdog = !led_watchdog;
    }
    //  2号定时器中断
    //  频率 16hz
    else if (htim == (&htim2))
    {
        threadmonitor_tim3 = 20;

        memcpy(transbuf + 3, &(robot.base.vector), 24);
        // memcpy(transbuf + 27, &(robot.target_inbase.vector), 24);
        memcpy(transbuf + 27, &(robot_im_pos.target_inbase.vector), 12);
        memcpy(transbuf + 39, (uint8_t *)&(robot_pos.target_inbase.vector.rx), 12);
        memcpy(transbuf + 51, &(robot.target_inworld.vector), 24);
        memcpy(transbuf + 75, &(robot_controller.state), 6);
        memcpy(transbuf + 81, &(imu), 50);
        memcpy(transbuf + 131, &(motorthrust_filted), 24);
        memcpy(transbuf + 155, &led, 2);

        // __HAL_UNLOCK(&huart4);
        HAL_UART_Transmit(&huart4, transbuf, 159, 10);

        // led
        if (led_dataup)
            HAL_GPIO_WritePin(GPIOD, GPIO_PIN_1, GPIO_PIN_SET);
        else
            HAL_GPIO_WritePin(GPIOD, GPIO_PIN_1, GPIO_PIN_RESET);
        led_dataup = !led_dataup;
    }
    //  3号定时器中断
    //  频率 40hz
    else if (htim == (&htim3))
    {
        // threadmonitor_tim2 = 20;

        // // Cs data refresh
        robot.base.vector.x  = imu.pos.x;
        robot.base.vector.y  = imu.pos.y;
        robot.base.vector.z  = imu.pos.z;
        robot.base.vector.rx = imu.pos.rx;
        robot.base.vector.ry = imu.pos.ry;
        robot.base.vector.rz = imu.pos.rz;

        // // refresh CoordinateSystems
        // robot.base.extract(&(robot.base));

        // // Cs transform
        // robot.world2base(&robot);

        // 计算各控制器所需测量值与误差值DF
        // 机器人坐标
        robot_im_pos.base.vector.x = robot_pos.base.vector.x = imu.pos.x;
        robot_im_pos.base.vector.y = robot_pos.base.vector.y = imu.pos.y;
        robot_im_pos.base.vector.z = robot_pos.base.vector.z = imu.pos.z;

        // 目标位置
        robot_im_pos.target_inworld.vector.x = robot_pos.target_inworld.vector.x = robot.target_inworld.vector.x;
        robot_im_pos.target_inworld.vector.y = robot_pos.target_inworld.vector.y = robot.target_inworld.vector.y;
        robot_im_pos.target_inworld.vector.z = robot_pos.target_inworld.vector.z = robot.target_inworld.vector.z;
        robot_im_pos.target_inworld.vector.rz = robot_pos.target_inworld.vector.rz = robot.target_inworld.vector.rz;
        robot_im_pos.target_inworld.extract(&(robot_im_pos.target_inworld));

        // 姿态
        robot_pos.base.vector.rx = imu.pos.rx;
        robot_pos.base.vector.ry = imu.pos.ry;
        robot_pos.base.vector.rz = imu.pos.rz;
        robot_pos.base.extract(&(robot_pos.base));

        robot_im_spd.base.vector.rx = robot_im_thrust.base.vector.rx = robot_pos.base.vector.rx;
        robot_im_spd.base.vector.ry = robot_im_thrust.base.vector.ry = robot_pos.base.vector.ry;
        robot_im_pos.base.vector.rz                                  = robot_pos.base.vector.rz;


        // 导出各参考系变换器对象的基底矩阵
        robot_im_pos.base.extract(&(robot_im_pos.base));
        robot_im_spd.base.extract(&(robot_im_spd.base));
        robot_im_thrust.base.extract(&(robot_im_thrust.base));

        // 计算机器人的水平横移与前进速度
        robot_im_spd.target_inbase.vector.x = imu.spd.x;
        robot_im_spd.target_inbase.vector.y = imu.spd.y;
        robot_im_spd.target_inbase.vector.z = imu.spd.z;
        robot_im_spd.target_inbase.extract(&(robot_im_spd.target_inbase));
        robot_im_spd.base2world(&robot_im_spd);

        // 计算机器人参考系中的水平误差（横向与前向）
        robot_im_pos.world2base(&robot_im_pos);


        // Pid controller refresh
        if (robot_controller.state[0] == 1) // x
            Tx = robot_controller.x.refresh(&robot_controller.x, robot_im_pos.target_inbase.vector.x);
        else
            Tx = openloop_thrust[0];

        if (robot_controller.state[1] == 1) // y
            Ty = robot_controller.y.refresh(&robot_controller.y, robot_im_pos.target_inbase.vector.y);
        else
            Ty = openloop_thrust[1];

        if (robot_controller.state[2] == 1) // z
            Tz = robot_controller.z.refresh(&robot_controller.z, robot_im_pos.target_inbase.vector.z) + 400;
        else
            Tz = openloop_thrust[2];

        // 姿态控制器
        robot_pos.target_inworld.vector.ry = Ry;
        robot_pos.target_inworld.extract(&(robot_pos.target_inworld));
        robot_pos.world2base(&robot_pos);


        if (robot_controller.state[3] == 1) // rx
            //Mx = robot_controller.rx.refresh(&robot_controller.rx, AngleCorrect(robot_pos.target_inbase.vector.rx));
            Mx = 0;
        else
            //Mx = openloop_thrust[3];
            Mx = 0;
        if (robot_controller.state[4] == 1) // ry
            My = robot_controller.ry.refresh(&robot_controller.ry, AngleCorrect(robot_pos.target_inbase.vector.ry));
        else
            My = openloop_thrust[4];

        if (robot_controller.state[5] == 1) // rz
            Mz = robot_controller.rz.refresh(&robot_controller.rz, AngleCorrect(robot_pos.target_inbase.vector.rz));
        else
            Mz = openloop_thrust[5];


        // 推力换算
        // Tx = NEGATIVE_BUOYANCY * tan(robot_pos.base.vector.ry * deg2rad);

        robot_im_thrust.target_inworld.vector.x = Tx;
        robot_im_thrust.target_inworld.vector.y = Ty;
        robot_im_thrust.target_inworld.vector.z = Tz;
        robot_im_thrust.target_inworld.extract(&(robot_im_thrust.target_inworld));
        robot_im_thrust.world2base(&robot_im_thrust);

        askedthrust[0] = robot_im_thrust.target_inbase.vector.x;
        askedthrust[1] = robot_im_thrust.target_inbase.vector.y;
        askedthrust[2] = robot_im_thrust.target_inbase.vector.z;

        robot_im_thrust.target_inworld.vector.x = Mx;
        robot_im_thrust.target_inworld.vector.y = My;
        robot_im_thrust.target_inworld.vector.z = Mz;
        robot_im_thrust.target_inworld.extract(&(robot_im_thrust.target_inworld));
        robot_im_thrust.world2base(&robot_im_thrust);

        askedthrust[3] = robot_im_thrust.target_inbase.vector.x;
        askedthrust[4] = robot_im_thrust.target_inbase.vector.y;
        askedthrust[5] = robot_im_thrust.target_inbase.vector.z;


        // allocate thrust
        ThrustAllocate(askedthrust, motorthrust);

        // thrust filter
        // for (int i = 0; i < 6; i++) { motorthrust_filted[i] = meanfilter[i].refresh(&(meanfilter[i]), motorthrust[i]); }
        for (int i = 0; i < 6; i++) { motorthrust_filted[i] = motorthrust[i]; }

        // Convert thrust signal to PWM signal
        MotorPwmRefresh(motorthrust_filted);

        // led
        if (led_motion)
            HAL_GPIO_WritePin(GPIOD, GPIO_PIN_0, GPIO_PIN_SET);
        else
            HAL_GPIO_WritePin(GPIOD, GPIO_PIN_0, GPIO_PIN_RESET);
        led_motion = !led_motion;
    }
}
/* USER CODE END 0 */

/**
 * @brief  The application entry point.
 * @retval int
 */
int main(void)
{
    /* USER CODE BEGIN 1 */

    /* USER CODE END 1 */

    /* MCU Configuration--------------------------------------------------------*/

    /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
    HAL_Init();

    /* USER CODE BEGIN Init */

    /* USER CODE END Init */

    /* Configure the system clock */
    SystemClock_Config();

    /* USER CODE BEGIN SysInit */

    /* USER CODE END SysInit */

    /* Initialize all configured peripherals */
    MX_GPIO_Init();
    MX_TIM5_Init();
    MX_UART4_Init();
    MX_UART7_Init();
    MX_TIM2_Init();
    MX_TIM3_Init();
    MX_TIM4_Init();
    MX_TIM1_Init();
    MX_I2C1_Init();
    MX_TIM6_Init();
    /* USER CODE BEGIN 2 */
    // uart it start
    CommInit();
    Ms5837Init(&hi2c1);

    // LED init
    HAL_GPIO_WritePin(GPIOD, GPIO_PIN_0, GPIO_PIN_SET);
    HAL_GPIO_WritePin(GPIOD, GPIO_PIN_1, GPIO_PIN_SET);
    HAL_GPIO_WritePin(GPIOD, GPIO_PIN_2, GPIO_PIN_SET);
    HAL_GPIO_WritePin(GPIOD, GPIO_PIN_3, GPIO_PIN_SET);
    HAL_GPIO_WritePin(GPIOD, GPIO_PIN_4, GPIO_PIN_SET);
    HAL_GPIO_WritePin(GPIOD, GPIO_PIN_5, GPIO_PIN_SET);
    HAL_GPIO_WritePin(GPIOD, GPIO_PIN_6, GPIO_PIN_SET);
    HAL_GPIO_WritePin(GPIOD, GPIO_PIN_7, GPIO_PIN_SET);

    // motor init
    MotorInit();

    //led init
    HAL_TIM_PWM_Start(&htim4, TIM_CHANNEL_3);   
    HAL_TIM_PWM_Start(&htim4, TIM_CHANNEL_4);
    __HAL_TIM_SetCompare(&htim4, TIM_CHANNEL_3, 0);
    __HAL_TIM_SetCompare(&htim4, TIM_CHANNEL_4, 0);

    // Data init
    CoordinateSystems_Init(&robot);  // Robot CS
    CoordinateSystems_Init(&target); // target CS

    // 机器人描述矩阵初始化
    CoordinateSystems_Init(&robot_pos);
    CoordinateSystems_Init(&robot_im_pos);
    CoordinateSystems_Init(&robot_im_spd);
    CoordinateSystems_Init(&robot_im_thrust);


    robot_controller.state[0] = robot_controller.state[1] = robot_controller.state[2] = 0;
    robot_controller.state[3] = robot_controller.state[4] = robot_controller.state[5] = 0;
    PositionalPID_Init(&(robot_controller.x), 0, 0, 0, 0, 0);  // X pid controller
    PositionalPID_Init(&(robot_controller.y), 0, 0, 0, 0, 0);  // y pid controller
    PositionalPID_Init(&(robot_controller.z), 0, 0, 0, 0, 0);  // z pid controller
    PositionalPID_Init(&(robot_controller.rx), 0, 0, 0, 0, 0); // pitch pid controller
    PositionalPID_Init(&(robot_controller.ry), 0, 0, 0, 0, 0); // roll pid controller
    PositionalPID_Init(&(robot_controller.rz), 0, 0, 0, 0, 0); // yaw pid controller
    transbuf[0]   = 0xfa;
    transbuf[1]   = 0xaf;
    transbuf[2]   = 0x00;
    transbuf[157] = 0xfb;
    transbuf[158] = 0xbf;

    MeanFilter_Init(&(meanfilter[0]), thrust_mean_filter_length);
    MeanFilter_Init(&(meanfilter[1]), thrust_mean_filter_length);
    MeanFilter_Init(&(meanfilter[2]), thrust_mean_filter_length);
    MeanFilter_Init(&(meanfilter[3]), thrust_mean_filter_length);
    MeanFilter_Init(&(meanfilter[4]), thrust_mean_filter_length);
    MeanFilter_Init(&(meanfilter[5]), thrust_mean_filter_length);

    ThrustCurveInit(&(thrustcurve[0]));
    ThrustCurveInit(&(thrustcurve[1]));
    ThrustCurveInit(&(thrustcurve[2]));
    ThrustCurveInit(&(thrustcurve[3]));
    ThrustCurveInit(&(thrustcurve[4]));
    ThrustCurveInit(&(thrustcurve[5]));

    // start data process
    HAL_TIM_Base_Start_IT(&htim2);
    HAL_TIM_Base_Start_IT(&htim3);

    // HAL_Delay(1000);
    // HAL_TIM_Base_Start_IT(&htim1);
    /* USER CODE END 2 */

    /* Infinite loop */
    /* USER CODE BEGIN WHILE */
    Ms5837Read(&hi2c1);
    Ms5837Depth(&startdepth);
    checkeddepth = startdepth;

    while (1)
    {
        Ms5837Read(&hi2c1);
        Ms5837Depth(&measureddepth);
        realdepth = measureddepth - startdepth;
        KalmanFilter(realdepth, &checkeddepth);
        imu.pos.z = checkeddepth;

        // 信号灯控制
        //绿灯
        if(led[0] == 0)
            __HAL_TIM_SetCompare(&htim4, TIM_CHANNEL_3, 0);
        else
            __HAL_TIM_SetCompare(&htim4, TIM_CHANNEL_3, 40000);
        //红灯
        if(led[1] == 0)
            __HAL_TIM_SetCompare(&htim4, TIM_CHANNEL_4, 0);
        else
            __HAL_TIM_SetCompare(&htim4, TIM_CHANNEL_4, 40000);

        /* USER CODE END WHILE */

        /* USER CODE BEGIN 3 */
        // led
        if (led_main)
            HAL_GPIO_WritePin(GPIOD, GPIO_PIN_4, GPIO_PIN_SET);
        else
            HAL_GPIO_WritePin(GPIOD, GPIO_PIN_4, GPIO_PIN_RESET);
        led_main = !led_main;

        HAL_Delay(50);
    }
    /* USER CODE END 3 */
}

/**
 * @brief System Clock Configuration
 * @retval None
 */
void SystemClock_Config(void)
{
    RCC_OscInitTypeDef RCC_OscInitStruct = {0};
    RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

    /** Supply configuration update enable
     */
    HAL_PWREx_ConfigSupply(PWR_LDO_SUPPLY);

    /** Configure the main internal regulator output voltage
     */
    __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);

    while (!__HAL_PWR_GET_FLAG(PWR_FLAG_VOSRDY)) {}

    /** Initializes the RCC Oscillators according to the specified parameters
     * in the RCC_OscInitTypeDef structure.
     */
    RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
    RCC_OscInitStruct.HSEState       = RCC_HSE_ON;
    RCC_OscInitStruct.PLL.PLLState   = RCC_PLL_ON;
    RCC_OscInitStruct.PLL.PLLSource  = RCC_PLLSOURCE_HSE;
    RCC_OscInitStruct.PLL.PLLM       = 2;
    RCC_OscInitStruct.PLL.PLLN       = 50;
    RCC_OscInitStruct.PLL.PLLP       = 2;
    RCC_OscInitStruct.PLL.PLLQ       = 2;
    RCC_OscInitStruct.PLL.PLLR       = 2;
    RCC_OscInitStruct.PLL.PLLRGE     = RCC_PLL1VCIRANGE_3;
    RCC_OscInitStruct.PLL.PLLVCOSEL  = RCC_PLL1VCOWIDE;
    RCC_OscInitStruct.PLL.PLLFRACN   = 0;
    if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK) { Error_Handler(); }

    /** Initializes the CPU, AHB and APB buses clocks
     */
    RCC_ClkInitStruct.ClockType =
        RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2 | RCC_CLOCKTYPE_D3PCLK1 | RCC_CLOCKTYPE_D1PCLK1;
    RCC_ClkInitStruct.SYSCLKSource   = RCC_SYSCLKSOURCE_PLLCLK;
    RCC_ClkInitStruct.SYSCLKDivider  = RCC_SYSCLK_DIV1;
    RCC_ClkInitStruct.AHBCLKDivider  = RCC_HCLK_DIV2;
    RCC_ClkInitStruct.APB3CLKDivider = RCC_APB3_DIV2;
    RCC_ClkInitStruct.APB1CLKDivider = RCC_APB1_DIV2;
    RCC_ClkInitStruct.APB2CLKDivider = RCC_APB2_DIV2;
    RCC_ClkInitStruct.APB4CLKDivider = RCC_APB4_DIV2;

    if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK) { Error_Handler(); }
}

/* USER CODE BEGIN 4 */

/* USER CODE END 4 */

/**
 * @brief  This function is executed in case of error occurrence.
 * @retval None
 */
void Error_Handler(void)
{
    /* USER CODE BEGIN Error_Handler_Debug */
    /* User can add his own implementation to report the HAL error return state */
    __disable_irq();
    while (1) {}
    /* USER CODE END Error_Handler_Debug */
}

#ifdef USE_FULL_ASSERT
/**
 * @brief  Reports the name of the source file and the source line number
 *         where the assert_param error has occurred.
 * @param  file: pointer to the source file name
 * @param  line: assert_param error line source number
 * @retval None
 */
void assert_failed(uint8_t *file, uint32_t line)
{
    /* USER CODE BEGIN 6 */
    /* User can add his own implementation to report the file name and line number,
       ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
    /* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */
---- code end ----

==== AutoControl/autocontrol.h ====
Description: Aggregator for control modules.
---- code begin ----
#ifndef __AUTO_CONTROL_H
#define __AUTO_CONTROL_H

#pragma pack(1)

#include "coordinate_system.h"
#include "pid_models.h"
#include "filter.h"

#endif
---- code end ----

==== AutoControl/coordinate_system.h ====
Description: Coordinate/pose data structures.
---- code begin ----
#ifndef __COORDINATE_SYSTEM_H
#define __COORDINATE_SYSTEM_H

#include <stdio.h>
#include <stdlib.h>
#include <math.h>

#ifndef deg2rad
#define deg2rad 0.01745329252f
#endif

#ifndef rad2deg
#define rad2deg 57.29577951f
#endif


#ifndef pi
#define pi 3.141592654f
#endif

typedef struct {
    float x;
    float y;
    float z;
    float rx;       // 绕X的旋转角 pitch
    float ry;       // 绕Y的旋转角 roll
    float rz;       // 绕Z的旋转角 yaw
} CoordinateVector; // 一个结构体，用于描述与机器人相关的坐标系统

/*
此处仅考虑机器人的位置变换关系
矩阵的分布为逐列从上至下
映射关系如下
0  | 1  | 2  | 3
4  | 5  | 6  | 7
8  | 9  | 10 | 11
12 | 13 | 14 | 15
*/
typedef struct {
    CoordinateVector vector;       // 位置与姿态
    float            h_matrix[16]; // 齐次矩阵
    void (*extract)(void *);       // 将 位置姿态参数 导出为 齐次矩阵
    void (*r_extract)(void *);     // 将 齐次矩阵 导出为 位置姿态参数
} MotionState; // 一个结构体，用于某一坐标系中机器人的运动状态

typedef struct {
    MotionState base;           // 世界坐标系 中的 机器人 的运动状态
    MotionState target_inbase;  // 机器人坐标系 中的 目标 的运动状态
    MotionState target_inworld; // 世界坐标系 中的 目标 的运动状态

    void (*world2base)(void *); // 坐标系变换 世界 => 机器人
    void (*base2world)(void *); // 坐标系变换 机器人 => 世界
} CoordinateSystems;            // 完整的描述


void  CoordinateSystems_Init(CoordinateSystems *CSs);
float AngleCorrect(float angle);

#endif
---- code end ----

==== AutoControl/coordinate_system.c ====
Description: Homogeneous transform helpers, angle wrap, and world/base conversions.
---- code begin ----
#include "coordinate_system.h"

/*
 * 函数名: AngleCorrect
 * 描述  : 角度矫正
 * 输入  : float  待矫正角度
 * 输出  : float  正确角度
 * 备注  : /
 */
float AngleCorrect(float angle)
{
    int cnt = 0;
    if (angle > 180)
    {
        cnt = (int)((angle + 180) / 360);
        angle -= cnt * 360;
    }
    if (angle < -180)
    {
        cnt = (int)((angle - 180) / 360);
        angle -= cnt * 360;
    }
    return angle;
}

/*
 * 函数名: matrixInverse
 * 描述  : 4*4 矩阵求逆
 * 输入  : 略
 * 输出  : /
 * 备注  : /
 */
void swap(float *a, float *b)
{
    float temp = *a;
    *a         = *b;
    *b         = temp;
}
void matrixInverse(float *input, float *result)
{
    float matrix[4][8];

    // 初始化增广矩阵
    for (int i = 0; i < 4; i++)
    {
        for (int j = 0; j < 4; j++)
        {
            matrix[i][j]     = input[i * 4 + j];
            matrix[i][j + 4] = (i == j) ? 1.0f : 0.0f;
        }
    }

    // 消元过程
    for (int i = 0; i < 4; i++)
    {
        // 如果当前行的对角线元素为0，则需要进行行交换
        if (matrix[i][i] == 0)
        {
            int row = i + 1;
            while (row < 4 && matrix[row][i] == 0) { row++; }

            // 如果找到了非零元素的行，则进行交换
            if (row < 4)
            {
                for (int j = 0; j < 8; j++) { swap(&matrix[i][j], &matrix[row][j]); }
            }
        }

        // 将对角线元素调整为1
        float scale = matrix[i][i];
        for (int j = 0; j < 8; j++) { matrix[i][j] /= scale; }

        // 消元
        for (int j = 0; j < 4; j++)
        {
            if (j != i)
            {
                float factor = matrix[j][i];
                for (int k = 0; k < 8; k++) { matrix[j][k] -= factor * matrix[i][k]; }
            }
        }
    }

    // 提取逆矩阵部分
    for (int i = 0; i < 4; i++)
    {
        for (int j = 0; j < 4; j++) { result[i * 4 + j] = matrix[i][j + 4]; }
    }
}


/*
 * 函数名: multiplyMatrix
 * 描述  : 4*4 矩阵乘法
 * 输入  : 略
 * 输出  : /
 * 备注  : /
 */
void multiplyMatrix(float *m1, float *m2, float *result)
{
    for (int i = 0; i < 4; i++)
    {
        for (int j = 0; j < 4; j++)
        {
            result[i * 4 + j] = 0.0;
            for (int k = 0; k < 4; k++) { result[i * 4 + j] += m1[i * 4 + k] * m2[k * 4 + j]; }
        }
    }
}

/*
 * 函数名: Target_CS_world2base
 * 描述  :
 * 对象CoordinateSystems的子方法，用于将目标的绝对坐标系中的运动状态参量转换为相对坐标系中的运动状态参量
 * 输入  : /
 * 输出  : /
 * 备注  : 仅计算位置、姿态的变换
 */
void Target_CS_world2base(void *obj)
{
    CoordinateSystems *CSs      = (CoordinateSystems *)obj;
    float              base[16] = {0};

    matrixInverse(CSs->base.h_matrix, base);
    multiplyMatrix(base, CSs->target_inworld.h_matrix, CSs->target_inbase.h_matrix);

    // 解算出欧拉角
    CSs->target_inbase.r_extract(&(CSs->target_inbase));
}

/*
 * 函数名: Target_CS_base2world
 * 描述  :
 * 对象CoordinateSystems的子方法，用于将目标的相对坐标系中的运动状态参量转换为绝对坐标系中的运动状态参量
 * 输入  : /
 * 输出  : /
 * 备注  : 仅计算位置、姿态的变换
 */
void Target_CS_base2world(void *obj)
{
    CoordinateSystems *CSs = (CoordinateSystems *)obj;

    // 矩阵相乘    base * target_inbase = target_inworld
    multiplyMatrix(CSs->base.h_matrix, CSs->target_inbase.h_matrix, CSs->target_inworld.h_matrix);

    // 解算出欧拉角
    CSs->target_inworld.r_extract(&(CSs->target_inworld));
}

/*
 * 函数名: MotionState_Extract
 * 描述  : 将 位置姿态参数 导出为 齐次矩阵
 * 输入  : /
 * 输出  : /
 * 备注  : /
 */
void MotionState_Extract(void *obj)
{
    MotionState *Ms = (MotionState *)obj;

    float Sx = sin(Ms->vector.rx * deg2rad);
    float Cx = cos(Ms->vector.rx * deg2rad);
    float Sy = sin(Ms->vector.ry * deg2rad);
    float Cy = cos(Ms->vector.ry * deg2rad);
    float Sz = sin(Ms->vector.rz * deg2rad);
    float Cz = cos(Ms->vector.rz * deg2rad);

    // 矩阵计算
    Ms->h_matrix[0] = Cy * Cz;
    Ms->h_matrix[1] = Sx * Sy * Cz - Cx * Sz;
    Ms->h_matrix[2] = Cx * Sy * Cz + Sx * Sz;
    Ms->h_matrix[3] = Ms->vector.x;

    Ms->h_matrix[4] = Cy * Sz;
    Ms->h_matrix[5] = Sx * Sy * Sz + Cx * Cz;
    Ms->h_matrix[6] = Cx * Sy * Sz - Sx * Cz;
    Ms->h_matrix[7] = Ms->vector.y;

    Ms->h_matrix[8]  = -Sy;
    Ms->h_matrix[9]  = Sx * Cy;
    Ms->h_matrix[10] = Cx * Cy;
    Ms->h_matrix[11] = Ms->vector.z;

    Ms->h_matrix[12] = 0.0f;
    Ms->h_matrix[13] = 0.0f;
    Ms->h_matrix[14] = 0.0f;
    Ms->h_matrix[15] = 1.0f;
}

/*
 * 函数名: MotionState_ReExtract
 * 描述  : 将 齐次矩阵 导出为 位置姿态参数
 * 输入  : /
 * 输出  : /
 * 备注  : /
 */
void MotionState_ReExtract(void *obj)
{
    MotionState *Ms = (MotionState *)obj;

    Ms->vector.x = Ms->h_matrix[3];
    Ms->vector.y = Ms->h_matrix[7];
    Ms->vector.z = Ms->h_matrix[11];

    float rx1, rx2;
    float ry1, ry2;

    if (Ms->h_matrix[8] != 1.0f || Ms->h_matrix[8] != -1.0f) // 若越界，放弃更新
    {
        ry1 = -asin(Ms->h_matrix[8]);
        ry2 = pi - ry1;

        rx1 = atan2(Ms->h_matrix[9] / cos(ry1), Ms->h_matrix[10] / cos(ry1));
        rx2 = atan2(Ms->h_matrix[9] / cos(ry2), Ms->h_matrix[10] / cos(ry2));

        if (ry1 < pi / 2 && ry1 > -pi / 2) Ms->vector.ry = ry1 * rad2deg;
        if (ry2 < pi / 2 && ry2 > -pi / 2) Ms->vector.ry = ry2 * rad2deg;

        if (rx1 < pi / 2 && rx1 > -pi / 2) Ms->vector.rx = rx1 * rad2deg;
        if (rx2 < pi / 2 && rx2 > -pi / 2) Ms->vector.rx = rx2 * rad2deg;

        // if (rz1 < pi && rz1 > -pi)
        Ms->vector.rz = atan2(Ms->h_matrix[4] / cos(Ms->vector.ry * deg2rad), Ms->h_matrix[0] / cos(Ms->vector.ry * deg2rad)) * rad2deg;
        // if (rz2 < pi && rz2 > -pi)
        //     Ms->vector.rz = rz2 * rad2deg;
    }
}

/*
 * 函数名: Motionstate_Init
 * 描述  : 机器人的运动状态描述量初始化
 * 输入  : MotionState * input
 * 输出  : /
 * 备注  : 赋值函数
 */
void Motionstate_Init(MotionState *input)
{
    input->vector.x  = 0.0f;
    input->vector.y  = 0.0f;
    input->vector.z  = 0.0f;
    input->vector.rx = 0.0f;
    input->vector.ry = 0.0f;
    input->vector.rz = 0.0f;

    input->extract   = MotionState_Extract;
    input->r_extract = MotionState_ReExtract;

    input->extract(input);
}

/*
 * 函数名: CoordinateSystems_Init
 * 描述  : 将机器人坐标描述初始化
 * 输入  : /
 * 输出  : CoordinateSystems_Init 完整的坐标系系统 对象
 * 备注  : /
 */
void CoordinateSystems_Init(CoordinateSystems *CSs)
{
    // 成员变量初始化
    Motionstate_Init(&(CSs->base));
    Motionstate_Init(&(CSs->target_inbase));
    Motionstate_Init(&(CSs->target_inworld));

    // 绑定方法
    CSs->world2base = Target_CS_world2base;
    CSs->base2world = Target_CS_base2world;
}
---- code end ----

==== AutoControl/pid_models.h ====
Description: PID controller structures.
---- code begin ----
#ifndef __PID_MODELS_H
#define __PID_MODELS_H

#include <stdio.h>
#include <stdlib.h>
#include <math.h>

// 位置式PID
typedef struct
{
    // 控制器参数
    float kp;
    float ki;
    float kd;
    float i_limit;
    float output_limit;

    // 状态参量
    float output;
    float delta;   // 差值
    float delta_i; // 差值积分
    float delta_d; // 差值微分

    float delta_l; // 上一步差值
    int delta_cnt; // 上一步差值 时间

    // 不参与运算
    // int cnt;  // 模型完成后的时间

    // 不难发现 K与delta_d等价
    // 一次函数模型中的 b 项无效
    float k, b; // 一次函数 参量

    float (*refresh)(void *, float); // 控制器更新
} PositionalPID;

void PositionalPID_Init(PositionalPID *Ppid, float kp, float ki, float kd, float i_limit, float output_limit);

#endif
---- code end ----

==== AutoControl/pid_models.c ====
Description: Position PID implementation with limits.
---- code begin ----
#include "pid_models.h"

/*
 * 函数名: Abs
 * 描述  : 绝对值函数
 * 输入  : 待求绝对值
 * 输出  : 绝对值
 * 备注  : /
 */
float Abs(float input)
{
    if (input < 0)
        return -input;
    else
        return input;
}

/*
 * 函数名: Limit
 * 描述  : 限幅函数
 * 输入  : float input 待限幅量
 *         float limit 限制
 * 输出  : 略
 * 备注  : /
 */
float Limit(float input, float limit)
{
    if (input < -Abs(limit))
        return -Abs(limit);
    else if (input > Abs(limit))
        return Abs(limit);
    else
        return input;
}

/*
 * 函数名: PositionalPID_Refresh
 * 描述  : 位置式PID控制器更新
 * 输入  : 差值
 * 输出  : /
 * 备注  : /
 */
float PositionalPID_Refresh(void *obj, float delta)
{
    PositionalPID *Ppid   = (PositionalPID *)obj;
    float          output = 0;
    // 不难发现 K与delta_d等价
    // 一次函数模型中的 b 项无效
    // 对传感器更新速率较低的情况进行补偿
    if (fabs(Ppid->delta_l - delta) < fabs(delta*0.01))
    {
        // 传感器频率 小于 采样频率
        Ppid->delta_cnt++;
        Ppid->delta_d = Ppid->k;
    }
    else
    {
        if (Ppid->delta_cnt == 0) { Ppid->delta_d = delta - Ppid->delta_l; }
        else { Ppid->delta_d = Ppid->k = (delta - Ppid->delta_l) / Ppid->delta_cnt; }

        Ppid->delta_l   = delta;
        Ppid->delta_cnt = 0;
    }

    Ppid->delta = delta;

    Ppid->delta_i += delta;

    if (Ppid->i_limit != 0) Ppid->delta_i = Limit(Ppid->delta_i, Ppid->i_limit); // 积分限幅

    output = Ppid->kp * Ppid->delta + Ppid->ki * Ppid->delta_i + Ppid->kd * Ppid->delta_d;

    if (Ppid->output_limit != 0) output = Limit(output, Ppid->output_limit); // 输出限幅

    return output;
}

/*
 * 函数名: PositionalPID_Init
 * 描述  : 位置式PID控制器初始化
 * 输入  : 控制器参数
 * 输出  : /
 * 备注  : /
 */
void PositionalPID_Init(PositionalPID *Ppid, float kp, float ki, float kd, float i_limit, float output_limit)
{
    // 参量初始化
    Ppid->kp           = kp;
    Ppid->ki           = ki;
    Ppid->kd           = kd;
    Ppid->i_limit      = i_limit;
    Ppid->output_limit = output_limit;

    Ppid->delta     = 0.0f;
    Ppid->delta_i   = 0.0f;
    Ppid->delta_d   = 0.0f;
    Ppid->delta_l   = 0.0f;
    Ppid->delta_cnt = 1;
    Ppid->k         = 0.0f;

    // 方法绑定
    Ppid->refresh = PositionalPID_Refresh;
}
---- code end ----

==== AutoControl/filter.h ====
Description: Mean/Kalman filter definitions.
---- code begin ----
#ifndef __FILTER_H
#define __FILTER_H

#define KalmanFilter_Q 0.05     //过程噪声协方差
#define KalmanFilter_R 0.4      //测量噪声协方差
#define FLITER_LENGTH 10        //滑动窗口长度

typedef struct {
    int   length;
    float list[256];
    float (*refresh)(void *,float input);
} MeanFilter;

void MeanFilter_Init(MeanFilter *filter, int length);
void KalmanFilter(float measured_value, float *pchecked_value);

#endif
---- code end ----

==== AutoControl/filter.c ====
Description: Mean filter and depth Kalman filter.
---- code begin ----
#include "filter.h"

float MeanFilter_Refresh(void *obj, float input)
{
    MeanFilter *f = (MeanFilter *)obj;

    volatile float output = 0;

    f->list[f->length - 1] = input;
    for (int i = 1; i < f->length; i++) { f->list[i - 1] = f->list[i]; }

    for (int i = 0; i < f->length; i++) { output += f->list[i]; }


    return output / ((float)f->length);
}

void MeanFilter_Init(MeanFilter *filter, int length)
{
    if (length < 2) length = 2;
    if (length > 256) length = 256;
    filter->length = length;

    for (int i = 0; i < length; i++) { filter->list[i] = 0; }

    filter->refresh = MeanFilter_Refresh;
}

void KalmanFilter(float measured_value, float *pchecked_value)
{
    static float x_est = 0.0; // 估计值
    static float p     = 1.0; // 方差
    static float k     = 0.0; // 卡尔曼增益

    // 预测
    float x_pred = x_est;
    float p_pred = p + KalmanFilter_Q;

    // 更新
    k     = p_pred / (p_pred + KalmanFilter_R);
    x_est = x_pred + k * (measured_value - x_pred);
    p     = (1 - k) * p_pred;

    *pchecked_value = x_est;
}
---- code end ----

==== Device/Inc/comm.h ====
Description: UART buffer, IMU struct, and control prototypes.
---- code begin ----
#ifndef __COMM_H
#define __COMM_H

#include "autocontrol.h"
#include "usart.h"

#define UART_RX_STATE_START 0
#define UART_RX_STATE_READY 2
#define UART_RX_STATE_DEAL 1

typedef struct {
    uint8_t          buf[256];      // 接收数据缓存数组
    volatile uint8_t rx_len;        // 接收一帧数据的长度
    volatile uint8_t recv_end_flag; // 一帧数据接收完成标志
    int              cnt;
} RecBuf;

typedef struct {
    uint8_t imustate;
    uint8_t dvlstate;

    CoordinateVector pos;
    CoordinateVector spd;
} IMU;

extern uint8_t dvlstate;
extern IMU imu;

extern RecBuf uart4rec;
extern RecBuf uart7rec;

void CommInit(void);
void dvl_shutdown(UART_HandleTypeDef *huart);
void dvl_startup(UART_HandleTypeDef *huart);
void imu_setmode(UART_HandleTypeDef *huart);

#endif
---- code end ----

==== Device/Src/comm.c ====
Description: UART4 commands parsing, UART7 IMU/DVL parsing, PID/target updates, thrust curve updates, LED control.
---- code begin ----
#include "comm.h"
#include "usart.h"
#include "main.h"
#include "motor.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

RecBuf uart4rec = {0};
RecBuf uart7rec = {0};

uint8_t dvlstate = 0;

IMU imu;

extern int threadmonitor_uart4;
extern int threadmonitor_uart7;
extern float checkeddepth;
extern uint8_t led[2];

extern CoordinateSystems target;


/*
 * 函数名: imu_setmode
 * 描述  : 设置室内导航模式
 * 输入  : /
 * 输出  : /
 * 备注  : /
 */
void imu_setmode(UART_HandleTypeDef *huart)
{
    uint8_t BUFIMUSETMODE[14] = {0xFC, 0xCF, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x31, 0xFD, 0xDF};
    HAL_UART_Transmit(huart, BUFIMUSETMODE, 14, 10); // 设置室内导航模式
}

/*
 * 函数名: dvl_shutdown
 * 描述  : 关闭Dvl
 * 输入  : /
 * 输出  : /
 * 备注  : /
 */
void dvl_shutdown(UART_HandleTypeDef *huart)
{
    uint8_t BUFDVLSHUTDOWN[14] = {0xFC, 0xCF, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0xFD, 0xDF};
    HAL_UART_Transmit(huart, BUFDVLSHUTDOWN, 14, 10); // 关闭DVL
}

/*
 * 函数名: dvl_startup
 * 描述  : 开启Dvl
 * 输入  : /
 * 输出  : /
 * 备注  : /
 */
void dvl_startup(UART_HandleTypeDef *huart)
{
    uint8_t BUFDVLPOWERON[14] = {0xFC, 0xCF, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x31, 0xFD, 0xDF};
    HAL_UART_Transmit(huart, BUFDVLPOWERON, 14, 10); // 关闭DVL
}

/*
 * 函数名: CommInit
 * 描述  : 串口通信初始化
 * 输入  : /
 * 输出  : /
 * 备注  : /
 */
void CommInit(void)
{
    uart4rec.cnt = 0;
    uart7rec.cnt = 0;

    // __HAL_UART_CLEAR_OREFLAG(&huart4);
    // huart4.RxState = HAL_UART_STATE_READY;
    // huart4.Lock    = HAL_UNLOCKED;

    // __HAL_UART_CLEAR_OREFLAG(&huart7);
    // huart7.RxState = HAL_UART_STATE_READY;
    // huart7.Lock    = HAL_UNLOCKED;

    HAL_UART_Receive_IT(&huart4, uart4rec.buf, 1);
    HAL_UART_Receive_IT(&huart7, uart7rec.buf, 1);


    HAL_Delay(100); // 稍作延迟防止无法进入中断
}

/*
 * 函数名: Check_Data
 * 描述  : 异或校验
 * 输入  : /
 * 输出  : /
 * 备注  : /
 */
uint8_t Check_Data(uint8_t *data, uint8_t size)
{
    uint8_t temp, i;
    temp = data[0];
    for (i = 1; i < size; i++) { temp = temp ^ data[i]; }
    return temp;
}

/*
 * 函数名: ImuSolve
 * 描述  : Imu数据解算
 * 输入  : /
 * 输出  : /
 * 备注  : /
 */
void ImuSolve(uint8_t *buf)
{
    float   imu_data[12]; // 前6位位置姿态矢量 后6位速度矢量
    uint8_t check;

    check = Check_Data(buf, 91);

    if (buf[0] == 0xfa && buf[1] == 0xaf && check == buf[91]) // 校验帧头
    {
        // 读数据缓冲
        memcpy(&(imu_data[3]), buf + 2, 12); // 姿态
        memcpy(&(imu_data[0]), buf + 54, 8); // x y
        memcpy(&(imu_data[2]), buf + 80, 4); // Z
        imu.imustate = buf[66];              // 导航状态
        imu.dvlstate = buf[67];
        // memcpy(&imu_data[6], buf + 26, 12);  // 速度
        // memcpy(&(imu.spd.ry), buf + 68, 4);  // 横滚速度
        // memcpy(&(imu.spd.rx), buf + 72, 4);  // 俯仰速度
        // memcpy(&(imu.spd.rz), buf + 76, 4);  // 转向速度

        // 读取IMU数据
        imu.pos.y  = imu_data[0];
        imu.pos.x  = -imu_data[1];
        //imu.pos.z  = imu_data[2];
        imu.pos.z = checkeddepth;
        imu.pos.ry = imu_data[3];
        imu.pos.rx = imu_data[4];
        imu.pos.rz = imu_data[5];
        // if (imu_data[0] > -10 && imu_data[0] < 10) imu.pos.y = imu_data[0];
        // if (imu_data[1] > -10 && imu_data[1] < 10) imu.pos.x = -imu_data[1];
        // if (imu_data[2] > 0 && imu_data[2] < 5) imu.pos.z = imu_data[2];
        // if (imu_data[3] > -180 && imu_data[3] < 180) imu.pos.ry = imu_data[3];
        // if (imu_data[4] > -180 && imu_data[4] < 180) imu.pos.rx = imu_data[4];
        // if (imu_data[5] > -180 && imu_data[5] < 180) imu.pos.rz = imu_data[5];

        // imu.spd.x = -imu_data[6];
        // imu.spd.y = imu_data[7];
        // imu.spd.z = imu_data[8];
    }

    // led
    if (led_uart7)
        HAL_GPIO_WritePin(GPIOD, GPIO_PIN_3, GPIO_PIN_SET);
    else
        HAL_GPIO_WritePin(GPIOD, GPIO_PIN_3, GPIO_PIN_RESET);
    led_uart7 = !led_uart7;
}

/*
 * 函数名: CmdSolve
 * 描述  : 下行命令解算
 * 输入  : /
 * 输出  : /
 * 备注  : /
 */
void CmdSolve(uint8_t *buf)
{
    switch (buf[2])
    {
        case 0x01: // 开关指定轴上的PID控制
            memcpy(&(robot_controller.state), buf + 3, 6);
            break;
        case 0x02: // 推力设置
            memcpy(openloop_thrust, buf + 3, 24);
            break;
        case 0x03: // 目标位置下行
            // 移动至指定位置
            if (buf[3] == 0x00)
            {
                memcpy(&(robot.target_inworld.vector), buf + 4, 24);
                robot.target_inworld.extract(&(robot.target_inworld));
            }
            // 移动相对距离
            else if (buf[3] == 0x01)
            {
                memcpy(&(robot.target_inbase.vector), buf + 4, 24);
                robot.target_inbase.extract(&(robot.target_inbase));
                robot.base2world(&robot);
            }
            // 目标值步进
            else if (buf[3] == 0x02)
            {
                memcpy(&(target.target_inbase.vector), buf + 4, 24);                         // 接收步进信息
                target.target_inbase.extract(&(target.target_inbase));                       // 更新齐次矩阵
                memcpy(&(target.base.vector), &(robot.target_inworld.vector), 24);           // 读取目标起始位置
                target.base.extract(&(target.base));                                         // 更新齐次矩阵
                target.base2world(&target);                                                  // 步进与起始位置叠加
                memcpy(&(robot.target_inworld.vector), &(target.target_inworld.vector), 24); // 写入目标位置
                robot.target_inworld.extract(&(robot.target_inworld));                       // 更新齐次矩阵
            }
            break;
        case 0x04: // IMU状态设置
            dvlstate = buf[3];
            break;
        case 0x05: // PID参数
            switch (buf[3])
            {
                case 0x00:
                    memcpy(&(robot_controller.x.kp), buf + 4, 4);
                    memcpy(&(robot_controller.x.ki), buf + 8, 4);
                    memcpy(&(robot_controller.x.kd), buf + 12, 4);
                    memcpy(&(robot_controller.x.i_limit), buf + 16, 4);
                    memcpy(&(robot_controller.x.output_limit), buf + 20, 4);
                    break;
                case 0x01:
                    memcpy(&(robot_controller.y.kp), buf + 4, 4);
                    memcpy(&(robot_controller.y.ki), buf + 8, 4);
                    memcpy(&(robot_controller.y.kd), buf + 12, 4);
                    memcpy(&(robot_controller.y.i_limit), buf + 16, 4);
                    memcpy(&(robot_controller.y.output_limit), buf + 20, 4);
                    break;
                case 0x02:
                    memcpy(&(robot_controller.z.kp), buf + 4, 4);
                    memcpy(&(robot_controller.z.ki), buf + 8, 4);
                    memcpy(&(robot_controller.z.kd), buf + 12, 4);
                    memcpy(&(robot_controller.z.i_limit), buf + 16, 4);
                    memcpy(&(robot_controller.z.output_limit), buf + 20, 4);
                    break;
                case 0x03:
                    memcpy(&(robot_controller.rx.kp), buf + 4, 4);
                    memcpy(&(robot_controller.rx.ki), buf + 8, 4);
                    memcpy(&(robot_controller.rx.kd), buf + 12, 4);
                    memcpy(&(robot_controller.rx.i_limit), buf + 16, 4);
                    memcpy(&(robot_controller.rx.output_limit), buf + 20, 4);
                    break;
                case 0x04:
                    memcpy(&(robot_controller.ry.kp), buf + 4, 4);
                    memcpy(&(robot_controller.ry.ki), buf + 8, 4);
                    memcpy(&(robot_controller.ry.kd), buf + 12, 4);
                    memcpy(&(robot_controller.ry.i_limit), buf + 16, 4);
                    memcpy(&(robot_controller.ry.output_limit), buf + 20, 4);
                    break;
                case 0x05:
                    memcpy(&(robot_controller.rz.kp), buf + 4, 4);
                    memcpy(&(robot_controller.rz.ki), buf + 8, 4);
                    memcpy(&(robot_controller.rz.kd), buf + 12, 4);
                    memcpy(&(robot_controller.rz.i_limit), buf + 16, 4);
                    memcpy(&(robot_controller.rz.output_limit), buf + 20, 4);
                    break;
                default: break;
            }
            break;

        case 0x07: // 推力曲线
            memcpy(&(thrustcurve[buf[3]].pwm[0]), buf + 4, 4);
            memcpy(&(thrustcurve[buf[3]].pwm[1]), buf + 8, 4);
            memcpy(&(thrustcurve[buf[3]].pwm[2]), buf + 12, 4);
            memcpy(&(thrustcurve[buf[3]].pwm[3]), buf + 16, 4);

            memcpy(&(thrustcurve[buf[3]].thrust[0]), buf + 20, 4);
            memcpy(&(thrustcurve[buf[3]].thrust[1]), buf + 24, 4);
            memcpy(&(thrustcurve[buf[3]].thrust[2]), buf + 28, 4);
            memcpy(&(thrustcurve[buf[3]].thrust[3]), buf + 32, 4);
            break;
        
        case 0x08: // LED控制
            if (buf[3] == 0)
                led[0] = 0;
            else
                led[0] = 1;
            if (buf[4] == 0)
                led[1] = 0;
            else
                led[1] = 1;
            
        default: break;
    }

    // led
    if (led_uart4)
        HAL_GPIO_WritePin(GPIOD, GPIO_PIN_2, GPIO_PIN_SET);
    else
        HAL_GPIO_WritePin(GPIOD, GPIO_PIN_2, GPIO_PIN_RESET);
    led_uart4 = !led_uart4;
}

/*
 * 函数名: HAL_UART_RxCpltCallback
 * 描述  : 串口中断处理
 * 输入  : UART_HandleTypeDef *huart 串口地址
 * 输出  : /
 * 备注  : /
 */
void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart) // 串口接收中断
{
    // 串口接收控制指令
    if (huart == &huart4)
    {
        threadmonitor_uart4 = 200;
        if (uart4rec.buf[uart4rec.cnt - 1] == 0xfa && uart4rec.buf[uart4rec.cnt] == 0xaf && uart4rec.cnt > 0)
        {
            uart4rec.cnt    = 1;
            uart4rec.buf[0] = 0xfa;
            uart4rec.buf[1] = 0xaf;
        }
        if (uart4rec.buf[uart4rec.cnt - 1] == 0xfb && uart4rec.buf[uart4rec.cnt] == 0xbf && uart4rec.cnt > 0)
        {
            CmdSolve(uart4rec.buf);
            uart4rec.cnt = 201; // 使缓冲计数归零
        }
        if (uart4rec.cnt > 200) // 防止缓冲溢出
            uart4rec.cnt = 0;
        else
            uart4rec.cnt++;

        HAL_UART_Receive_IT(&huart4, uart4rec.buf + uart4rec.cnt, 1);
    }

    // 惯性导航系统
    if (huart == &huart7)
    {
        threadmonitor_uart7 = 100;
        if (uart7rec.buf[uart7rec.cnt - 1] == 0xfa && uart7rec.buf[uart7rec.cnt] == 0xaf && uart7rec.cnt > 0)
        {
            uart7rec.cnt    = 1;
            uart7rec.buf[0] = 0xfa;
            uart7rec.buf[1] = 0xaf;
        }
        if (uart7rec.buf[uart7rec.cnt - 1] == 0xfb && uart7rec.buf[uart7rec.cnt] == 0xbf && uart7rec.cnt > 5)
        {
            ImuSolve(uart7rec.buf);
            uart7rec.cnt = 201; // 使缓冲计数归零
        }
        if (uart7rec.cnt > 200) // 防止缓冲溢出
            uart7rec.cnt = 0;
        else
            uart7rec.cnt++;

        __HAL_UART_CLEAR_OREFLAG(&huart7);
        huart7.RxState = HAL_UART_STATE_READY;
        huart7.Lock    = HAL_UNLOCKED;

        HAL_UART_Receive_IT(&huart7, uart7rec.buf + uart7rec.cnt, 1);
    }
}
---- code end ----

==== Device/Inc/motor.h ====
Description: Motor PWM constants and thrust curve struct.
---- code begin ----
#ifndef __MOTOR_H
#define __MOTOR_H

#include "autocontrol.h"

#define Motor_Pwm_Change_Speed_HIGH 160
#define Motor_Pwm_Change_Speed_LOW 20
#define Motor_Pwm_Median_Duty 3000
#define Motor_Pwm_Half_Range 1000
#define Motor_Pwm_Half_Range_N 840
#define Motor_Pwm_Half_Range_P 720


typedef struct {
    float pwm[4];
    float thrust[4];
} ThrustCurve;


extern ThrustCurve thrustcurve[6];

void ThrustCurveInit(ThrustCurve *thrustcurve);
void MotorInit(void);
void MotorPwmRefresh(float *motorthrust);


#endif
---- code end ----

==== Device/Src/motor.c ====
Description: Thrust-to-PWM mapping, ESC init, PWM refresh for six motors.
---- code begin ----
#include "motor.h"
#include "tim.h"

ThrustCurve thrustcurve[6];


const int motornum[6] = {0, 1, 2, 3, 4, 5};

float line(float startx, float endx, float starty, float endy, float input)
{
    float k = (endy - starty) / (endx - startx);
    return starty + k * (input - startx);
}

/*
 * 函数名:Thrust2PWM
 * 描述  :推力曲线拟合
 * 输入  :int motornum 电机序号 float Thrust 推力大小
 * 输出  :int PWM数据
 * 备注  :利用C语言取整特性查表
 */
int Thrust2PWM(int num, float thrust)
{
    volatile int mnum;

    volatile float pwm = Motor_Pwm_Median_Duty;

    if (fabs(thrust) <= 1e-4) return Motor_Pwm_Median_Duty;

    mnum = motornum[num];

    if (thrust <= thrustcurve[mnum].thrust[0])
        pwm = Motor_Pwm_Median_Duty - Motor_Pwm_Half_Range_N;
    else if (thrust > thrustcurve[mnum].thrust[0] && thrust <= thrustcurve[mnum].thrust[1])
    {
        pwm = line(thrustcurve[mnum].thrust[0], thrustcurve[mnum].thrust[1], Motor_Pwm_Median_Duty - Motor_Pwm_Half_Range_N, thrustcurve[mnum].pwm[0],
                   thrust);
    }
    else if (thrust > thrustcurve[mnum].thrust[1] && thrust <= 0)
    {
        pwm = line(thrustcurve[mnum].thrust[1], 0, thrustcurve[mnum].pwm[0], thrustcurve[mnum].pwm[1], thrust);
    }
    else if (thrust > 0 && thrust <= thrustcurve[mnum].thrust[2])
    {
        pwm = line(0, thrustcurve[mnum].thrust[2], thrustcurve[mnum].pwm[2], thrustcurve[mnum].pwm[3], thrust);
    }
    else if (thrust > thrustcurve[mnum].thrust[2] && thrust < thrustcurve[mnum].thrust[3])
    {
        pwm = line(thrustcurve[mnum].thrust[2], thrustcurve[mnum].thrust[3], thrustcurve[mnum].pwm[3], Motor_Pwm_Median_Duty + Motor_Pwm_Half_Range_P,
                   thrust);
    }
    else if (thrust >= thrustcurve[mnum].thrust[3])
        pwm = Motor_Pwm_Median_Duty + Motor_Pwm_Half_Range_P;

    return (int)(pwm + 0.5);
}

void ThrustCurveInit(ThrustCurve *thrustcurve)
{
    thrustcurve->pwm[0] = Motor_Pwm_Median_Duty - 0.5 * Motor_Pwm_Half_Range;
    thrustcurve->pwm[1] = Motor_Pwm_Median_Duty;
    thrustcurve->pwm[2] = Motor_Pwm_Median_Duty;
    thrustcurve->pwm[3] = Motor_Pwm_Median_Duty + 0.5 * Motor_Pwm_Half_Range;

    thrustcurve->thrust[0] = -1500.0f;
    thrustcurve->thrust[1] = -750.0f;
    thrustcurve->thrust[2] = 750.0f;
    thrustcurve->thrust[3] = 1500.0f;
}


/*
 * 函数名: MotorInit
 * 描述  : 开启PWM输出，初始化电调，做油门校准
 * 输入  : /
 * 输出  : /
 * 备注  : 频率50hz psc=39999 中值3000 min 2000 max 4000
 */
void MotorInit(void)
{
    // 开启PWM输出
    HAL_TIM_PWM_Start(&htim4, TIM_CHANNEL_1);
    HAL_TIM_PWM_Start(&htim4, TIM_CHANNEL_2);
    HAL_TIM_PWM_Start(&htim5, TIM_CHANNEL_1);
    HAL_TIM_PWM_Start(&htim5, TIM_CHANNEL_2);
    HAL_TIM_PWM_Start(&htim5, TIM_CHANNEL_3);
    HAL_TIM_PWM_Start(&htim5, TIM_CHANNEL_4);
    // __HAL_TIM_SetCompare(&htim4, TIM_CHANNEL_1, 0);
    // __HAL_TIM_SetCompare(&htim4, TIM_CHANNEL_2, 0);
    // __HAL_TIM_SetCompare(&htim5, TIM_CHANNEL_1, 0);
    // __HAL_TIM_SetCompare(&htim5, TIM_CHANNEL_2, 0);
    // __HAL_TIM_SetCompare(&htim5, TIM_CHANNEL_3, 0);
    // __HAL_TIM_SetCompare(&htim5, TIM_CHANNEL_4, 0);
    // HAL_Delay(1000);


    // 电调校准
    // __HAL_TIM_SetCompare(&htim4, TIM_CHANNEL_1, Motor_Pwm_Median_Duty + Motor_Pwm_Half_Range);
    // __HAL_TIM_SetCompare(&htim4, TIM_CHANNEL_2, Motor_Pwm_Median_Duty + Motor_Pwm_Half_Range);
    // __HAL_TIM_SetCompare(&htim5, TIM_CHANNEL_1, Motor_Pwm_Median_Duty + Motor_Pwm_Half_Range);
    // __HAL_TIM_SetCompare(&htim5, TIM_CHANNEL_2, Motor_Pwm_Median_Duty + Motor_Pwm_Half_Range);
    // __HAL_TIM_SetCompare(&htim5, TIM_CHANNEL_3, Motor_Pwm_Median_Duty + Motor_Pwm_Half_Range);
    // __HAL_TIM_SetCompare(&htim5, TIM_CHANNEL_4, Motor_Pwm_Median_Duty + Motor_Pwm_Half_Range);
    // HAL_Delay(1000);
    // HAL_Delay(1000);
    // HAL_Delay(1000);
    // __HAL_TIM_SetCompare(&htim4, TIM_CHANNEL_1, Motor_Pwm_Median_Duty - Motor_Pwm_Half_Range);
    // __HAL_TIM_SetCompare(&htim4, TIM_CHANNEL_2, Motor_Pwm_Median_Duty - Motor_Pwm_Half_Range);
    // __HAL_TIM_SetCompare(&htim5, TIM_CHANNEL_1, Motor_Pwm_Median_Duty - Motor_Pwm_Half_Range);
    // __HAL_TIM_SetCompare(&htim5, TIM_CHANNEL_2, Motor_Pwm_Median_Duty - Motor_Pwm_Half_Range);
    // __HAL_TIM_SetCompare(&htim5, TIM_CHANNEL_3, Motor_Pwm_Median_Duty - Motor_Pwm_Half_Range);
    // __HAL_TIM_SetCompare(&htim5, TIM_CHANNEL_4, Motor_Pwm_Median_Duty - Motor_Pwm_Half_Range);
    // HAL_Delay(1000);
    // HAL_Delay(1000);
    __HAL_TIM_SetCompare(&htim4, TIM_CHANNEL_1, Motor_Pwm_Median_Duty);
    __HAL_TIM_SetCompare(&htim4, TIM_CHANNEL_2, Motor_Pwm_Median_Duty);
    __HAL_TIM_SetCompare(&htim5, TIM_CHANNEL_1, Motor_Pwm_Median_Duty);
    __HAL_TIM_SetCompare(&htim5, TIM_CHANNEL_2, Motor_Pwm_Median_Duty);
    __HAL_TIM_SetCompare(&htim5, TIM_CHANNEL_3, Motor_Pwm_Median_Duty);
    __HAL_TIM_SetCompare(&htim5, TIM_CHANNEL_4, Motor_Pwm_Median_Duty);
    // HAL_Delay(1000);
    // HAL_Delay(1000);
}

/*
 * 函数名: MotorPwmRefresh
 * 描述  : PWM输出更新
 * 输入  : 电机被分配的推力 0~5 对应电机 0~5
 * 输出  : /
 * 备注  : 输入、输出同时反转时可使推力曲线反转
 */
void MotorPwmRefresh(float *motorthrust)
{
    // 变量初始化
    volatile static int pwmtarget[6] = {Motor_Pwm_Median_Duty, Motor_Pwm_Median_Duty, Motor_Pwm_Median_Duty,
                                        Motor_Pwm_Median_Duty, Motor_Pwm_Median_Duty, Motor_Pwm_Median_Duty};

    volatile static int pwmoutput[6] = {Motor_Pwm_Median_Duty, Motor_Pwm_Median_Duty, Motor_Pwm_Median_Duty,
                                        Motor_Pwm_Median_Duty, Motor_Pwm_Median_Duty, Motor_Pwm_Median_Duty};

                                    
    // motorthrust[0] = -motorthrust[0]; 使输入反转
    motorthrust[0] = -motorthrust[0];
    motorthrust[1] = -motorthrust[1];
    motorthrust[2] = -motorthrust[2];
    motorthrust[3] = -motorthrust[3];
    motorthrust[4] = -motorthrust[4];
    motorthrust[5] = -motorthrust[5];


    // 对输出信号做模糊控制
    for (int i = 0; i < 6; i++)
    {
        pwmoutput[i] = pwmtarget[i] = Thrust2PWM(i, motorthrust[i]);

        // if (abs(pwmoutput[i] - Motor_Pwm_Median_Duty) < 200)
        // {
        //     int delta = abs(pwmoutput[i] - pwmtarget[i]);
        //     float pwm_change_speed;

        //     // 使用一个比例因子来动态计算步进值，例如每差50增加5的步进
        //     pwm_change_speed = 3 + ((float)delta / 50.0) * 5;

        //     // 确保步进值不超过一个最大限定值，比如50
        //     if (pwm_change_speed > 50) 
        //     {
        //         pwm_change_speed = 50;
        //     }

        //     // 调整PWM输出以靠近目标值
        //     if (pwmoutput[i] < pwmtarget[i] - pwm_change_speed) {
        //         pwmoutput[i] += pwm_change_speed;
        //     } else if (pwmoutput[i] > pwmtarget[i] + pwm_change_speed) {
        //         pwmoutput[i] -= pwm_change_speed;
        //     }
        // }        
        // else
        // {
        //     if (pwmoutput[i] < pwmtarget[i] - Motor_Pwm_Change_Speed_HIGH) pwmoutput[i] += Motor_Pwm_Change_Speed_HIGH;
        //     if (pwmoutput[i] > pwmtarget[i] + Motor_Pwm_Change_Speed_HIGH) pwmoutput[i] -= Motor_Pwm_Change_Speed_HIGH;
        // }
    }

    // 信号输出
    // __HAL_TIM_SetCompare(&htim4, TIM_CHANNEL_1, 2 * Motor_Pwm_Median_Duty - pwmoutput[0]);
    // e.g. 使输出反转

    __HAL_TIM_SetCompare(&htim5, TIM_CHANNEL_4, pwmoutput[0]);
    __HAL_TIM_SetCompare(&htim4, TIM_CHANNEL_1, 2 * Motor_Pwm_Median_Duty - pwmoutput[1]);
    __HAL_TIM_SetCompare(&htim5, TIM_CHANNEL_3, pwmoutput[2]);
    __HAL_TIM_SetCompare(&htim4, TIM_CHANNEL_2, 2 * Motor_Pwm_Median_Duty - pwmoutput[3]);
    __HAL_TIM_SetCompare(&htim5, TIM_CHANNEL_2, pwmoutput[4]);
    __HAL_TIM_SetCompare(&htim5, TIM_CHANNEL_1, 2 * Motor_Pwm_Median_Duty - pwmoutput[5]);
}
---- code end ----

==== Device/Inc/thrust.h ====
Description: Thrust allocation constants and prototype.
---- code begin ----
#ifndef __THRUST_H
#define __THRUST_H

#include "autocontrol.h"

// #define __A_1 0.178601329f
// #define __A_2 0.1760656194f
// #define __B 0.299777458f
// #define __C 0.275844479f
// #define __2b 0.216f

#define __A_1 0.20489f
#define __A_2 0.19341f
#define __B   0.45725f
#define __C   0.20475f
#define __2b  0.22000f

void ThrustAllocate(float *askedthrust, float *motorthrust);

#endif
---- code end ----

==== Device/Src/thrust.c ====
Description: Thrust allocation across six motors from xyz/attitude commands.
---- code begin ----
#include "thrust.h"

/*
 * 函数名: ThrustAllocate
 * 描述  : 推力分配
 * 输入  : askedthrust 0~5 对应 x y z rx ry rz
 *         motorthrust 电机被分配的推力 0~5 对应电机 0~5
 * 输出  : /
 * 备注  : /
 */
void ThrustAllocate(float *askedthrust, float *motorthrust)
{
    motorthrust[0] = -__A_2 * askedthrust[0] / __B + __C * askedthrust[1] + askedthrust[5] / __B;
    motorthrust[1] = __A_2 * askedthrust[0] / __B + __C * askedthrust[1] - askedthrust[5] / __B;
    motorthrust[2] = -0.5 * askedthrust[2] + askedthrust[4] / __2b;
    motorthrust[3] = -0.5 * askedthrust[2] - askedthrust[4] / __2b;
    motorthrust[4] = -__A_1 * askedthrust[0] / __B - __C * askedthrust[1] - askedthrust[5] / __B;
    motorthrust[5] = __A_1 * askedthrust[0] / __B - __C * askedthrust[1] + askedthrust[5] / __B;
}

---- code end ----

==== Device/Inc/ms5837.h ====
Description: MS5837 depth sensor register definitions and API.
---- code begin ----
#ifndef MS5837_H
#define MS5837_H

#include "stm32h7xx_hal.h"
#include "main.h"

// Definitions:
#define MS5837_ADDR            0x76

#define MS5837_RESET           0x1E
#define MS5837_ADC_READ        0x00
#define MS5837_PROM_READ       0xA0
#define MS5837_CONVERT_D1_8192 0x4A
#define MS5837_CONVERT_D2_8192 0x5A

// Models:
#define MS5837_30BA  0x00
#define MS5837_02BA  0x01

#define waterDensity = 1029;

struct MS5837_t {
    // MS5837 model(Default MS5837_30BA)
    uint8_t model;
    // Fluid density (Default 1029)
    float fluidDensity;
    // Pressure unit (Default mBar)
    float temperture;
    float pressure;
};

// Values red from MS5837
struct MS5837_values_t {
    int32_t TEMP;
    int32_t P;
    uint16_t C[8];
    uint32_t D1;
    uint32_t D2;
};

uint8_t Ms5837Init(I2C_HandleTypeDef *i2c_channel);
void Ms5837Read(I2C_HandleTypeDef *i2c_channel);
void Ms5837Depth(float *p);
// float altitude(float *p);

#endif
---- code end ----

==== Device/Src/ms5837.c ====
Description: MS5837 I2C read/calibration, pressure/depth conversion.
---- code begin ----
#include "MS5837.h"

struct MS5837_values_t MS5837_values;
struct MS5837_t MS5837;

inline static void I2C_send(uint8_t addr, I2C_HandleTypeDef *i2c_channel)
{
    HAL_I2C_Master_Transmit(i2c_channel, MS5837_ADDR << 1, &addr, 1, 100);
}

inline static int8_t I2C_read8(uint8_t addr, I2C_HandleTypeDef *i2c_channel)
{
    uint8_t data = 0;
    HAL_I2C_Master_Transmit(i2c_channel, MS5837_ADDR << 1, &addr, 1, 100);
    HAL_Delay(20);
    HAL_I2C_Master_Receive(i2c_channel, MS5837_ADDR << 1, &data, 1, 100);
    return data;
}

inline static int16_t I2C_read16(uint8_t addr, I2C_HandleTypeDef *i2c_channel)
{
    uint8_t dataArr[2] = {0, 0};
    HAL_I2C_Master_Transmit(i2c_channel, MS5837_ADDR << 1, &addr, 1, 100);
    HAL_Delay(20);
    HAL_I2C_Master_Receive(i2c_channel, MS5837_ADDR << 1, dataArr, 2, 100);
    uint16_t data = (dataArr[0] << 8) | dataArr[1];
    return data;
}

inline static int32_t I2C_read32(uint8_t addr, I2C_HandleTypeDef *i2c_channel)
{
    uint8_t dataArr[4] = {0, 0, 0, 0};
    HAL_I2C_Master_Transmit(i2c_channel, MS5837_ADDR << 1, &addr, 1, 100);
    HAL_Delay(20);
    HAL_I2C_Master_Receive(i2c_channel, MS5837_ADDR << 1, dataArr, 4, 100);
    uint32_t data = (dataArr[0] << 24) | (dataArr[1] << 16) | (dataArr[2] << 8) | dataArr[3];
    return data;
}

static uint8_t crc4(uint16_t n_prom[])
{
    uint16_t n_rem = 0;

    n_prom[0] = ((n_prom[0]) & 0x0FFF);
    n_prom[7] = 0;

    for (uint8_t i = 0; i < 16; i++) {
        if (i % 2 == 1) {
            n_rem ^= (uint16_t)((n_prom[i >> 1]) & 0x00FF);
        } else {
            n_rem ^= (uint16_t)(n_prom[i >> 1] >> 8);
        }
        for (uint8_t n_bit = 8; n_bit > 0; n_bit--) {
            if (n_rem & 0x8000) {
                n_rem = (n_rem << 1) ^ 0x3000;
            } else {
                n_rem = (n_rem << 1);
            }
        }
    }

    n_rem = ((n_rem >> 12) & 0x000F);

    return n_rem ^ 0x00;
}

static void calculate()
{

    int32_t dT    = 0;
    int64_t SENS  = 0;
    int64_t OFF   = 0;
    int32_t SENSi = 0;
    int32_t OFFi  = 0;
    int32_t Ti    = 0;
    int64_t OFF2  = 0;
    int64_t SENS2 = 0;

    dT = MS5837_values.D2 - (uint32_t)MS5837_values.C[5] * 256l;
    if (MS5837.model) {
        SENS            = (int64_t)MS5837_values.C[1] * 65536l + ((int64_t)MS5837_values.C[3] * dT) / 128l;
        OFF             = (int64_t)MS5837_values.C[2] * 131072l + ((int64_t)MS5837_values.C[4] * dT) / 64l;
        MS5837_values.P = (MS5837_values.D1 * SENS / (2097152l) - OFF) / (32768l);
    } else {
        SENS            = (int64_t)MS5837_values.C[1] * 32768l + ((int64_t)MS5837_values.C[3] * dT) / 256l;
        OFF             = (int64_t)MS5837_values.C[2] * 65536l + ((int64_t)MS5837_values.C[4] * dT) / 128l;
        MS5837_values.P = (MS5837_values.D1 * SENS / (2097152l) - OFF) / (8192l);
    }

    MS5837_values.TEMP = 2000l + (int64_t)dT * MS5837_values.C[6] / 8388608LL;

    if (MS5837.model) {
        if ((MS5837_values.TEMP / 100) < 20) {
            Ti    = (11 * (int64_t)dT * (int64_t)dT) / (34359738368LL);
            OFFi  = (31 * (MS5837_values.TEMP - 2000) * (MS5837_values.TEMP - 2000)) / 8;
            SENSi = (63 * (MS5837_values.TEMP - 2000) * (MS5837_values.TEMP - 2000)) / 32;
        }
    } else {
        if ((MS5837_values.TEMP / 100) < 20) {
            Ti    = (3 * (int64_t)dT * (int64_t)dT) / (8589934592LL);
            OFFi  = (3 * (MS5837_values.TEMP - 2000) * (MS5837_values.TEMP - 2000)) / 2;
            SENSi = (5 * (MS5837_values.TEMP - 2000) * (MS5837_values.TEMP - 2000)) / 8;
            if ((MS5837_values.TEMP / 100) < -15) {
                OFFi  = OFFi + 7 * (MS5837_values.TEMP + 1500l) * (MS5837_values.TEMP + 1500l);
                SENSi = SENSi + 4 * (MS5837_values.TEMP + 1500l) * (MS5837_values.TEMP + 1500l);
            }
        } else if ((MS5837_values.TEMP / 100) >= 20) {
            Ti    = 2 * (dT * dT) / (137438953472LL);
            OFFi  = (1 * (MS5837_values.TEMP - 2000) * (MS5837_values.TEMP - 2000)) / 16;
            SENSi = 0;
        }
    }

    OFF2  = OFF - OFFi;
    SENS2 = SENS - SENSi;

    if (MS5837.model) {
        MS5837_values.TEMP = (MS5837_values.TEMP - Ti);
        MS5837_values.P    = (((MS5837_values.D1 * SENS2) / 2097152l - OFF2) / 32768l) / 100;
    } else {
        MS5837_values.TEMP = (MS5837_values.TEMP - Ti);
        MS5837_values.P    = (((MS5837_values.D1 * SENS2) / 2097152l - OFF2) / 8192l) / 10;
    }

    MS5837.temperture = MS5837_values.TEMP / 100.0f;
    MS5837.pressure   = MS5837_values.P * 1.0f;
#ifdef Pa
    MS5837.pressure = MS5837_values.P * 100.0f;
#endif
#ifdef bar
    MS5837.pressure = MS5837_values.P * 0.001f;
#endif
}

uint8_t Ms5837Init(I2C_HandleTypeDef *i2c_channel)
{
    MS5837.fluidDensity = 1029;
    MS5837.model        = MS5837_30BA;

    I2C_send(MS5837_RESET, i2c_channel);
    HAL_Delay(10);

    for (uint8_t i = 0; i < 7; i++) {
        MS5837_values.C[i] = I2C_read16(MS5837_PROM_READ + (i * 2), i2c_channel);
        HAL_Delay(20);
    }
    uint8_t crcRead       = MS5837_values.C[0] >> 12;
    uint8_t crcCalculated = crc4(MS5837_values.C);

    if (crcCalculated == crcRead) {
        return 1;
    }

    return 0;
}

void Ms5837Read(I2C_HandleTypeDef *i2c_channel)
{
    I2C_send(MS5837_CONVERT_D1_8192, i2c_channel);
    HAL_Delay(20);

    MS5837_values.D1 = I2C_read32(MS5837_ADC_READ, i2c_channel);
    MS5837_values.D1 = MS5837_values.D1 >> 8;
    HAL_Delay(20);
    I2C_send(MS5837_CONVERT_D2_8192, i2c_channel);
    HAL_Delay(20);

    MS5837_values.D2 = I2C_read32(MS5837_ADC_READ, i2c_channel);
    MS5837_values.D2 = MS5837_values.D2 >> 8;

    calculate();
}

inline void Ms5837Depth(float *p)
{
    *p = (MS5837.pressure * 100.0f - 101300) / (MS5837.fluidDensity * 9.80665);
}

// inline float altitude(float *p)
// {
//     *p = (1 - pow((MS5837.pressure / 1013.25), .190284)) * 145366.45 * .3048;
// }
---- code end ----

==== Core/Inc/gpio.h ====
Description: GPIO prototypes.
---- code begin ----
/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file    gpio.h
  * @brief   This file contains all the function prototypes for
  *          the gpio.c file
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2023 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* USER CODE END Header */
/* Define to prevent recursive inclusion -------------------------------------*/
#ifndef __GPIO_H__
#define __GPIO_H__

#ifdef __cplusplus
extern "C" {
#endif

/* Includes ------------------------------------------------------------------*/
#include "main.h"

/* USER CODE BEGIN Includes */

/* USER CODE END Includes */

/* USER CODE BEGIN Private defines */

/* USER CODE END Private defines */

void MX_GPIO_Init(void);

/* USER CODE BEGIN Prototypes */

/* USER CODE END Prototypes */

#ifdef __cplusplus
}
#endif
#endif /*__ GPIO_H__ */

---- code end ----

==== Core/Src/gpio.c ====
Description: GPIO init for LEDs and other pins.
---- code begin ----
/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file    gpio.c
  * @brief   This file provides code for the configuration
  *          of all used GPIO pins.
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2023 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* USER CODE END Header */

/* Includes ------------------------------------------------------------------*/
#include "gpio.h"

/* USER CODE BEGIN 0 */

/* USER CODE END 0 */

/*----------------------------------------------------------------------------*/
/* Configure GPIO                                                             */
/*----------------------------------------------------------------------------*/
/* USER CODE BEGIN 1 */

/* USER CODE END 1 */

/** Configure pins
     PH0-OSC_IN (PH0)   ------> RCC_OSC_IN
     PH1-OSC_OUT (PH1)   ------> RCC_OSC_OUT
     PC7   ------> DEBUG_TRGIO
     PA13 (JTMS/SWDIO)   ------> DEBUG_JTMS-SWDIO
     PA14 (JTCK/SWCLK)   ------> DEBUG_JTCK-SWCLK
*/
void MX_GPIO_Init(void)
{

  GPIO_InitTypeDef GPIO_InitStruct = {0};

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOH_CLK_ENABLE();
  __HAL_RCC_GPIOA_CLK_ENABLE();
  __HAL_RCC_GPIOE_CLK_ENABLE();
  __HAL_RCC_GPIOD_CLK_ENABLE();
  __HAL_RCC_GPIOC_CLK_ENABLE();
  __HAL_RCC_GPIOB_CLK_ENABLE();

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOC, GPIO_PIN_12, GPIO_PIN_RESET);

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOD, GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3
                          |GPIO_PIN_4|GPIO_PIN_5|GPIO_PIN_6|GPIO_PIN_7, GPIO_PIN_RESET);

  /*Configure GPIO pin : PC12 */
  GPIO_InitStruct.Pin = GPIO_PIN_12;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);

  /*Configure GPIO pins : PD0 PD1 PD2 PD3
                           PD4 PD5 PD6 PD7 */
  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3
                          |GPIO_PIN_4|GPIO_PIN_5|GPIO_PIN_6|GPIO_PIN_7;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);

}

/* USER CODE BEGIN 2 */

/* USER CODE END 2 */
---- code end ----

==== Core/Inc/i2c.h ====
Description: I2C handle/prototype declarations.
---- code begin ----
/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file    i2c.h
  * @brief   This file contains all the function prototypes for
  *          the i2c.c file
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2024 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* USER CODE END Header */
/* Define to prevent recursive inclusion -------------------------------------*/
#ifndef __I2C_H__
#define __I2C_H__

#ifdef __cplusplus
extern "C" {
#endif

/* Includes ------------------------------------------------------------------*/
#include "main.h"

/* USER CODE BEGIN Includes */

/* USER CODE END Includes */

extern I2C_HandleTypeDef hi2c1;

/* USER CODE BEGIN Private defines */

/* USER CODE END Private defines */

void MX_I2C1_Init(void);

/* USER CODE BEGIN Prototypes */

/* USER CODE END Prototypes */

#ifdef __cplusplus
}
#endif

#endif /* __I2C_H__ */

---- code end ----

==== Core/Src/i2c.c ====
Description: I2C1 init on PB6/PB7 (timing 0x307075B1, analog filter on).
---- code begin ----
/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file    i2c.c
  * @brief   This file provides code for the configuration
  *          of the I2C instances.
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2024 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* USER CODE END Header */
/* Includes ------------------------------------------------------------------*/
#include "i2c.h"

/* USER CODE BEGIN 0 */

/* USER CODE END 0 */

I2C_HandleTypeDef hi2c1;

/* I2C1 init function */
void MX_I2C1_Init(void)
{

  /* USER CODE BEGIN I2C1_Init 0 */

  /* USER CODE END I2C1_Init 0 */

  /* USER CODE BEGIN I2C1_Init 1 */

  /* USER CODE END I2C1_Init 1 */
  hi2c1.Instance = I2C1;
  hi2c1.Init.Timing = 0x307075B1;
  hi2c1.Init.OwnAddress1 = 0;
  hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
  hi2c1.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
  hi2c1.Init.OwnAddress2 = 0;
  hi2c1.Init.OwnAddress2Masks = I2C_OA2_NOMASK;
  hi2c1.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
  hi2c1.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
  if (HAL_I2C_Init(&hi2c1) != HAL_OK)
  {
    Error_Handler();
  }

  /** Configure Analogue filter
  */
  if (HAL_I2CEx_ConfigAnalogFilter(&hi2c1, I2C_ANALOGFILTER_ENABLE) != HAL_OK)
  {
    Error_Handler();
  }

  /** Configure Digital filter
  */
  if (HAL_I2CEx_ConfigDigitalFilter(&hi2c1, 0) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN I2C1_Init 2 */

  /* USER CODE END I2C1_Init 2 */

}

void HAL_I2C_MspInit(I2C_HandleTypeDef* i2cHandle)
{

  GPIO_InitTypeDef GPIO_InitStruct = {0};
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
  if(i2cHandle->Instance==I2C1)
  {
  /* USER CODE BEGIN I2C1_MspInit 0 */

  /* USER CODE END I2C1_MspInit 0 */

  /** Initializes the peripherals clock
  */
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_I2C1;
    PeriphClkInitStruct.I2c123ClockSelection = RCC_I2C123CLKSOURCE_D2PCLK1;
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
    {
      Error_Handler();
    }

    __HAL_RCC_GPIOB_CLK_ENABLE();
    /**I2C1 GPIO Configuration
    PB6     ------> I2C1_SCL
    PB7     ------> I2C1_SDA
    */
    GPIO_InitStruct.Pin = GPIO_PIN_6|GPIO_PIN_7;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    GPIO_InitStruct.Alternate = GPIO_AF4_I2C1;
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);

    /* I2C1 clock enable */
    __HAL_RCC_I2C1_CLK_ENABLE();
  /* USER CODE BEGIN I2C1_MspInit 1 */

  /* USER CODE END I2C1_MspInit 1 */
  }
}

void HAL_I2C_MspDeInit(I2C_HandleTypeDef* i2cHandle)
{

  if(i2cHandle->Instance==I2C1)
  {
  /* USER CODE BEGIN I2C1_MspDeInit 0 */

  /* USER CODE END I2C1_MspDeInit 0 */
    /* Peripheral clock disable */
    __HAL_RCC_I2C1_CLK_DISABLE();

    /**I2C1 GPIO Configuration
    PB6     ------> I2C1_SCL
    PB7     ------> I2C1_SDA
    */
    HAL_GPIO_DeInit(GPIOB, GPIO_PIN_6);

    HAL_GPIO_DeInit(GPIOB, GPIO_PIN_7);

  /* USER CODE BEGIN I2C1_MspDeInit 1 */

  /* USER CODE END I2C1_MspDeInit 1 */
  }
}

/* USER CODE BEGIN 1 */

/* USER CODE END 1 */
---- code end ----

==== Core/Inc/tim.h ====
Description: Timer handles/prototypes.
---- code begin ----
/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file    tim.h
  * @brief   This file contains all the function prototypes for
  *          the tim.c file
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2023 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* USER CODE END Header */
/* Define to prevent recursive inclusion -------------------------------------*/
#ifndef __TIM_H__
#define __TIM_H__

#ifdef __cplusplus
extern "C" {
#endif

/* Includes ------------------------------------------------------------------*/
#include "main.h"

/* USER CODE BEGIN Includes */

/* USER CODE END Includes */

extern TIM_HandleTypeDef htim1;

extern TIM_HandleTypeDef htim2;

extern TIM_HandleTypeDef htim3;

extern TIM_HandleTypeDef htim4;

extern TIM_HandleTypeDef htim5;

extern TIM_HandleTypeDef htim6;

/* USER CODE BEGIN Private defines */

/* USER CODE END Private defines */

void MX_TIM1_Init(void);
void MX_TIM2_Init(void);
void MX_TIM3_Init(void);
void MX_TIM4_Init(void);
void MX_TIM5_Init(void);
void MX_TIM6_Init(void);

void HAL_TIM_MspPostInit(TIM_HandleTypeDef *htim);

/* USER CODE BEGIN Prototypes */

/* USER CODE END Prototypes */

#ifdef __cplusplus
}
#endif

#endif /* __TIM_H__ */

---- code end ----

==== Core/Src/tim.c ====
Description: TIM1/TIM2/TIM3/TIM4/TIM5/TIM6 PWM and base timer setup for motors, LEDs, watchdog, data uplink.
---- code begin ----
/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file    tim.c
  * @brief   This file provides code for the configuration
  *          of the TIM instances.
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2023 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* USER CODE END Header */
/* Includes ------------------------------------------------------------------*/
#include "tim.h"

/* USER CODE BEGIN 0 */

/* USER CODE END 0 */

TIM_HandleTypeDef htim1;
TIM_HandleTypeDef htim2;
TIM_HandleTypeDef htim3;
TIM_HandleTypeDef htim4;
TIM_HandleTypeDef htim5;
TIM_HandleTypeDef htim6;

/* TIM1 init function */
void MX_TIM1_Init(void)
{

  /* USER CODE BEGIN TIM1_Init 0 */

  /* USER CODE END TIM1_Init 0 */

  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
  TIM_MasterConfigTypeDef sMasterConfig = {0};

  /* USER CODE BEGIN TIM1_Init 1 */

  /* USER CODE END TIM1_Init 1 */
  htim1.Instance = TIM1;
  htim1.Init.Prescaler = 199;
  htim1.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim1.Init.Period = 19999;
  htim1.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  htim1.Init.RepetitionCounter = 0;
  htim1.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
  if (HAL_TIM_Base_Init(&htim1) != HAL_OK)
  {
    Error_Handler();
  }
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
  if (HAL_TIM_ConfigClockSource(&htim1, &sClockSourceConfig) != HAL_OK)
  {
    Error_Handler();
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
  sMasterConfig.MasterOutputTrigger2 = TIM_TRGO2_RESET;
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  if (HAL_TIMEx_MasterConfigSynchronization(&htim1, &sMasterConfig) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN TIM1_Init 2 */

  /* USER CODE END TIM1_Init 2 */

}
/* TIM2 init function */
void MX_TIM2_Init(void)
{

  /* USER CODE BEGIN TIM2_Init 0 */

  /* USER CODE END TIM2_Init 0 */

  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
  TIM_MasterConfigTypeDef sMasterConfig = {0};

  /* USER CODE BEGIN TIM2_Init 1 */

  /* USER CODE END TIM2_Init 1 */
  htim2.Instance = TIM2;
  htim2.Init.Prescaler = 199;
  htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim2.Init.Period = 62499;
  htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  htim2.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
  if (HAL_TIM_Base_Init(&htim2) != HAL_OK)
  {
    Error_Handler();
  }
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
  if (HAL_TIM_ConfigClockSource(&htim2, &sClockSourceConfig) != HAL_OK)
  {
    Error_Handler();
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  if (HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN TIM2_Init 2 */

  /* USER CODE END TIM2_Init 2 */

}
/* TIM3 init function */
void MX_TIM3_Init(void)
{

  /* USER CODE BEGIN TIM3_Init 0 */

  /* USER CODE END TIM3_Init 0 */

  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
  TIM_MasterConfigTypeDef sMasterConfig = {0};

  /* USER CODE BEGIN TIM3_Init 1 */

  /* USER CODE END TIM3_Init 1 */
  htim3.Instance = TIM3;
  htim3.Init.Prescaler = 199;
  htim3.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim3.Init.Period = 24999;
  htim3.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  htim3.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
  if (HAL_TIM_Base_Init(&htim3) != HAL_OK)
  {
    Error_Handler();
  }
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
  if (HAL_TIM_ConfigClockSource(&htim3, &sClockSourceConfig) != HAL_OK)
  {
    Error_Handler();
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  if (HAL_TIMEx_MasterConfigSynchronization(&htim3, &sMasterConfig) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN TIM3_Init 2 */

  /* USER CODE END TIM3_Init 2 */

}
/* TIM4 init function */
void MX_TIM4_Init(void)
{

  /* USER CODE BEGIN TIM4_Init 0 */

  /* USER CODE END TIM4_Init 0 */

  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
  TIM_MasterConfigTypeDef sMasterConfig = {0};
  TIM_OC_InitTypeDef sConfigOC = {0};

  /* USER CODE BEGIN TIM4_Init 1 */

  /* USER CODE END TIM4_Init 1 */
  htim4.Instance = TIM4;
  htim4.Init.Prescaler = 99;
  htim4.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim4.Init.Period = 39999;
  htim4.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  htim4.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
  if (HAL_TIM_Base_Init(&htim4) != HAL_OK)
  {
    Error_Handler();
  }
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
  if (HAL_TIM_ConfigClockSource(&htim4, &sClockSourceConfig) != HAL_OK)
  {
    Error_Handler();
  }
  if (HAL_TIM_PWM_Init(&htim4) != HAL_OK)
  {
    Error_Handler();
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  if (HAL_TIMEx_MasterConfigSynchronization(&htim4, &sMasterConfig) != HAL_OK)
  {
    Error_Handler();
  }
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
  sConfigOC.Pulse = 0;
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
  if (HAL_TIM_PWM_ConfigChannel(&htim4, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
  {
    Error_Handler();
  }
  if (HAL_TIM_PWM_ConfigChannel(&htim4, &sConfigOC, TIM_CHANNEL_2) != HAL_OK)
  {
    Error_Handler();
  }
  if (HAL_TIM_PWM_ConfigChannel(&htim4, &sConfigOC, TIM_CHANNEL_3) != HAL_OK)
  {
    Error_Handler();
  }
  if (HAL_TIM_PWM_ConfigChannel(&htim4, &sConfigOC, TIM_CHANNEL_4) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN TIM4_Init 2 */

  /* USER CODE END TIM4_Init 2 */
  HAL_TIM_MspPostInit(&htim4);

}
/* TIM5 init function */
void MX_TIM5_Init(void)
{

  /* USER CODE BEGIN TIM5_Init 0 */

  /* USER CODE END TIM5_Init 0 */

  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
  TIM_MasterConfigTypeDef sMasterConfig = {0};
  TIM_OC_InitTypeDef sConfigOC = {0};

  /* USER CODE BEGIN TIM5_Init 1 */

  /* USER CODE END TIM5_Init 1 */
  htim5.Instance = TIM5;
  htim5.Init.Prescaler = 99;
  htim5.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim5.Init.Period = 39999;
  htim5.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  htim5.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
  if (HAL_TIM_Base_Init(&htim5) != HAL_OK)
  {
    Error_Handler();
  }
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
  if (HAL_TIM_ConfigClockSource(&htim5, &sClockSourceConfig) != HAL_OK)
  {
    Error_Handler();
  }
  if (HAL_TIM_PWM_Init(&htim5) != HAL_OK)
  {
    Error_Handler();
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  if (HAL_TIMEx_MasterConfigSynchronization(&htim5, &sMasterConfig) != HAL_OK)
  {
    Error_Handler();
  }
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
  sConfigOC.Pulse = 0;
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
  if (HAL_TIM_PWM_ConfigChannel(&htim5, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
  {
    Error_Handler();
  }
  if (HAL_TIM_PWM_ConfigChannel(&htim5, &sConfigOC, TIM_CHANNEL_2) != HAL_OK)
  {
    Error_Handler();
  }
  if (HAL_TIM_PWM_ConfigChannel(&htim5, &sConfigOC, TIM_CHANNEL_3) != HAL_OK)
  {
    Error_Handler();
  }
  if (HAL_TIM_PWM_ConfigChannel(&htim5, &sConfigOC, TIM_CHANNEL_4) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN TIM5_Init 2 */

  /* USER CODE END TIM5_Init 2 */
  HAL_TIM_MspPostInit(&htim5);

}
/* TIM6 init function */
void MX_TIM6_Init(void)
{

  /* USER CODE BEGIN TIM6_Init 0 */

  /* USER CODE END TIM6_Init 0 */

  TIM_MasterConfigTypeDef sMasterConfig = {0};

  /* USER CODE BEGIN TIM6_Init 1 */

  /* USER CODE END TIM6_Init 1 */
  htim6.Instance = TIM6;
  htim6.Init.Prescaler = 10000-1;
  htim6.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim6.Init.Period = 10000-1;
  htim6.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
  if (HAL_TIM_Base_Init(&htim6) != HAL_OK)
  {
    Error_Handler();
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  if (HAL_TIMEx_MasterConfigSynchronization(&htim6, &sMasterConfig) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN TIM6_Init 2 */

  /* USER CODE END TIM6_Init 2 */

}

void HAL_TIM_Base_MspInit(TIM_HandleTypeDef* tim_baseHandle)
{

  if(tim_baseHandle->Instance==TIM1)
  {
  /* USER CODE BEGIN TIM1_MspInit 0 */

  /* USER CODE END TIM1_MspInit 0 */
    /* TIM1 clock enable */
    __HAL_RCC_TIM1_CLK_ENABLE();

    /* TIM1 interrupt Init */
    HAL_NVIC_SetPriority(TIM1_UP_IRQn, 1, 0);
    HAL_NVIC_EnableIRQ(TIM1_UP_IRQn);
  /* USER CODE BEGIN TIM1_MspInit 1 */

  /* USER CODE END TIM1_MspInit 1 */
  }
  else if(tim_baseHandle->Instance==TIM2)
  {
  /* USER CODE BEGIN TIM2_MspInit 0 */

  /* USER CODE END TIM2_MspInit 0 */
    /* TIM2 clock enable */
    __HAL_RCC_TIM2_CLK_ENABLE();

    /* TIM2 interrupt Init */
    HAL_NVIC_SetPriority(TIM2_IRQn, 13, 0);
    HAL_NVIC_EnableIRQ(TIM2_IRQn);
  /* USER CODE BEGIN TIM2_MspInit 1 */

  /* USER CODE END TIM2_MspInit 1 */
  }
  else if(tim_baseHandle->Instance==TIM3)
  {
  /* USER CODE BEGIN TIM3_MspInit 0 */

  /* USER CODE END TIM3_MspInit 0 */
    /* TIM3 clock enable */
    __HAL_RCC_TIM3_CLK_ENABLE();

    /* TIM3 interrupt Init */
    HAL_NVIC_SetPriority(TIM3_IRQn, 10, 0);
    HAL_NVIC_EnableIRQ(TIM3_IRQn);
  /* USER CODE BEGIN TIM3_MspInit 1 */

  /* USER CODE END TIM3_MspInit 1 */
  }
  else if(tim_baseHandle->Instance==TIM4)
  {
  /* USER CODE BEGIN TIM4_MspInit 0 */

  /* USER CODE END TIM4_MspInit 0 */
    /* TIM4 clock enable */
    __HAL_RCC_TIM4_CLK_ENABLE();
  /* USER CODE BEGIN TIM4_MspInit 1 */

  /* USER CODE END TIM4_MspInit 1 */
  }
  else if(tim_baseHandle->Instance==TIM5)
  {
  /* USER CODE BEGIN TIM5_MspInit 0 */

  /* USER CODE END TIM5_MspInit 0 */
    /* TIM5 clock enable */
    __HAL_RCC_TIM5_CLK_ENABLE();
  /* USER CODE BEGIN TIM5_MspInit 1 */

  /* USER CODE END TIM5_MspInit 1 */
  }
  else if(tim_baseHandle->Instance==TIM6)
  {
  /* USER CODE BEGIN TIM6_MspInit 0 */

  /* USER CODE END TIM6_MspInit 0 */
    /* TIM6 clock enable */
    __HAL_RCC_TIM6_CLK_ENABLE();
  /* USER CODE BEGIN TIM6_MspInit 1 */

  /* USER CODE END TIM6_MspInit 1 */
  }
}
void HAL_TIM_MspPostInit(TIM_HandleTypeDef* timHandle)
{

  GPIO_InitTypeDef GPIO_InitStruct = {0};
  if(timHandle->Instance==TIM4)
  {
  /* USER CODE BEGIN TIM4_MspPostInit 0 */

  /* USER CODE END TIM4_MspPostInit 0 */
    __HAL_RCC_GPIOD_CLK_ENABLE();
    /**TIM4 GPIO Configuration
    PD12     ------> TIM4_CH1
    PD13     ------> TIM4_CH2
    PD14     ------> TIM4_CH3
    PD15     ------> TIM4_CH4
    */
    GPIO_InitStruct.Pin = GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    GPIO_InitStruct.Alternate = GPIO_AF2_TIM4;
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);

  /* USER CODE BEGIN TIM4_MspPostInit 1 */

  /* USER CODE END TIM4_MspPostInit 1 */
  }
  else if(timHandle->Instance==TIM5)
  {
  /* USER CODE BEGIN TIM5_MspPostInit 0 */

  /* USER CODE END TIM5_MspPostInit 0 */

    __HAL_RCC_GPIOA_CLK_ENABLE();
    /**TIM5 GPIO Configuration
    PA0     ------> TIM5_CH1
    PA1     ------> TIM5_CH2
    PA2     ------> TIM5_CH3
    PA3     ------> TIM5_CH4
    */
    GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    GPIO_InitStruct.Alternate = GPIO_AF2_TIM5;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

  /* USER CODE BEGIN TIM5_MspPostInit 1 */

  /* USER CODE END TIM5_MspPostInit 1 */
  }

}

void HAL_TIM_Base_MspDeInit(TIM_HandleTypeDef* tim_baseHandle)
{

  if(tim_baseHandle->Instance==TIM1)
  {
  /* USER CODE BEGIN TIM1_MspDeInit 0 */

  /* USER CODE END TIM1_MspDeInit 0 */
    /* Peripheral clock disable */
    __HAL_RCC_TIM1_CLK_DISABLE();

    /* TIM1 interrupt Deinit */
    HAL_NVIC_DisableIRQ(TIM1_UP_IRQn);
  /* USER CODE BEGIN TIM1_MspDeInit 1 */

  /* USER CODE END TIM1_MspDeInit 1 */
  }
  else if(tim_baseHandle->Instance==TIM2)
  {
  /* USER CODE BEGIN TIM2_MspDeInit 0 */

  /* USER CODE END TIM2_MspDeInit 0 */
    /* Peripheral clock disable */
    __HAL_RCC_TIM2_CLK_DISABLE();

    /* TIM2 interrupt Deinit */
    HAL_NVIC_DisableIRQ(TIM2_IRQn);
  /* USER CODE BEGIN TIM2_MspDeInit 1 */

  /* USER CODE END TIM2_MspDeInit 1 */
  }
  else if(tim_baseHandle->Instance==TIM3)
  {
  /* USER CODE BEGIN TIM3_MspDeInit 0 */

  /* USER CODE END TIM3_MspDeInit 0 */
    /* Peripheral clock disable */
    __HAL_RCC_TIM3_CLK_DISABLE();

    /* TIM3 interrupt Deinit */
    HAL_NVIC_DisableIRQ(TIM3_IRQn);
  /* USER CODE BEGIN TIM3_MspDeInit 1 */

  /* USER CODE END TIM3_MspDeInit 1 */
  }
  else if(tim_baseHandle->Instance==TIM4)
  {
  /* USER CODE BEGIN TIM4_MspDeInit 0 */

  /* USER CODE END TIM4_MspDeInit 0 */
    /* Peripheral clock disable */
    __HAL_RCC_TIM4_CLK_DISABLE();
  /* USER CODE BEGIN TIM4_MspDeInit 1 */

  /* USER CODE END TIM4_MspDeInit 1 */
  }
  else if(tim_baseHandle->Instance==TIM5)
  {
  /* USER CODE BEGIN TIM5_MspDeInit 0 */

  /* USER CODE END TIM5_MspDeInit 0 */
    /* Peripheral clock disable */
    __HAL_RCC_TIM5_CLK_DISABLE();
  /* USER CODE BEGIN TIM5_MspDeInit 1 */

  /* USER CODE END TIM5_MspDeInit 1 */
  }
  else if(tim_baseHandle->Instance==TIM6)
  {
  /* USER CODE BEGIN TIM6_MspDeInit 0 */

  /* USER CODE END TIM6_MspDeInit 0 */
    /* Peripheral clock disable */
    __HAL_RCC_TIM6_CLK_DISABLE();
  /* USER CODE BEGIN TIM6_MspDeInit 1 */

  /* USER CODE END TIM6_MspDeInit 1 */
  }
}

/* USER CODE BEGIN 1 */

/* USER CODE END 1 */
---- code end ----

==== Core/Inc/usart.h ====
Description: UART handles/prototypes.
---- code begin ----
/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file    usart.h
  * @brief   This file contains all the function prototypes for
  *          the usart.c file
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2023 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* USER CODE END Header */
/* Define to prevent recursive inclusion -------------------------------------*/
#ifndef __USART_H__
#define __USART_H__

#ifdef __cplusplus
extern "C" {
#endif

/* Includes ------------------------------------------------------------------*/
#include "main.h"

/* USER CODE BEGIN Includes */

/* USER CODE END Includes */

extern UART_HandleTypeDef huart4;

extern UART_HandleTypeDef huart7;

/* USER CODE BEGIN Private defines */

/* USER CODE END Private defines */

void MX_UART4_Init(void);
void MX_UART7_Init(void);

/* USER CODE BEGIN Prototypes */

/* USER CODE END Prototypes */

#ifdef __cplusplus
}
#endif

#endif /* __USART_H__ */

---- code end ----

==== Core/Src/usart.c ====
Description: UART4 (control link) and UART7 (IMU/DVL) init.
---- code begin ----
/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file    usart.c
  * @brief   This file provides code for the configuration
  *          of the USART instances.
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2023 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* USER CODE END Header */
/* Includes ------------------------------------------------------------------*/
#include "usart.h"

/* USER CODE BEGIN 0 */

/* USER CODE END 0 */

UART_HandleTypeDef huart4;
UART_HandleTypeDef huart7;

/* UART4 init function */
void MX_UART4_Init(void)
{

  /* USER CODE BEGIN UART4_Init 0 */

  /* USER CODE END UART4_Init 0 */

  /* USER CODE BEGIN UART4_Init 1 */

  /* USER CODE END UART4_Init 1 */
  huart4.Instance = UART4;
  huart4.Init.BaudRate = 115200;
  huart4.Init.WordLength = UART_WORDLENGTH_8B;
  huart4.Init.StopBits = UART_STOPBITS_1;
  huart4.Init.Parity = UART_PARITY_NONE;
  huart4.Init.Mode = UART_MODE_TX_RX;
  huart4.Init.HwFlowCtl = UART_HWCONTROL_NONE;
  huart4.Init.OverSampling = UART_OVERSAMPLING_16;
  huart4.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
  huart4.Init.ClockPrescaler = UART_PRESCALER_DIV1;
  huart4.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
  if (HAL_UART_Init(&huart4) != HAL_OK)
  {
    Error_Handler();
  }
  if (HAL_UARTEx_SetTxFifoThreshold(&huart4, UART_TXFIFO_THRESHOLD_1_8) != HAL_OK)
  {
    Error_Handler();
  }
  if (HAL_UARTEx_SetRxFifoThreshold(&huart4, UART_RXFIFO_THRESHOLD_1_8) != HAL_OK)
  {
    Error_Handler();
  }
  if (HAL_UARTEx_DisableFifoMode(&huart4) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN UART4_Init 2 */

  /* USER CODE END UART4_Init 2 */

}
/* UART7 init function */
void MX_UART7_Init(void)
{

  /* USER CODE BEGIN UART7_Init 0 */

  /* USER CODE END UART7_Init 0 */

  /* USER CODE BEGIN UART7_Init 1 */

  /* USER CODE END UART7_Init 1 */
  huart7.Instance = UART7;
  huart7.Init.BaudRate = 256000;
  huart7.Init.WordLength = UART_WORDLENGTH_8B;
  huart7.Init.StopBits = UART_STOPBITS_1;
  huart7.Init.Parity = UART_PARITY_NONE;
  huart7.Init.Mode = UART_MODE_TX_RX;
  huart7.Init.HwFlowCtl = UART_HWCONTROL_NONE;
  huart7.Init.OverSampling = UART_OVERSAMPLING_16;
  huart7.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
  huart7.Init.ClockPrescaler = UART_PRESCALER_DIV1;
  huart7.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
  if (HAL_UART_Init(&huart7) != HAL_OK)
  {
    Error_Handler();
  }
  if (HAL_UARTEx_SetTxFifoThreshold(&huart7, UART_TXFIFO_THRESHOLD_1_8) != HAL_OK)
  {
    Error_Handler();
  }
  if (HAL_UARTEx_SetRxFifoThreshold(&huart7, UART_RXFIFO_THRESHOLD_1_8) != HAL_OK)
  {
    Error_Handler();
  }
  if (HAL_UARTEx_DisableFifoMode(&huart7) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN UART7_Init 2 */

  /* USER CODE END UART7_Init 2 */

}

void HAL_UART_MspInit(UART_HandleTypeDef* uartHandle)
{

  GPIO_InitTypeDef GPIO_InitStruct = {0};
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
  if(uartHandle->Instance==UART4)
  {
  /* USER CODE BEGIN UART4_MspInit 0 */

  /* USER CODE END UART4_MspInit 0 */

  /** Initializes the peripherals clock
  */
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_UART4;
    PeriphClkInitStruct.Usart234578ClockSelection = RCC_USART234578CLKSOURCE_D2PCLK1;
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
    {
      Error_Handler();
    }

    /* UART4 clock enable */
    __HAL_RCC_UART4_CLK_ENABLE();

    __HAL_RCC_GPIOA_CLK_ENABLE();
    /**UART4 GPIO Configuration
    PA11     ------> UART4_RX
    PA12     ------> UART4_TX
    */
    GPIO_InitStruct.Pin = GPIO_PIN_11|GPIO_PIN_12;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF6_UART4;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

    /* UART4 interrupt Init */
    HAL_NVIC_SetPriority(UART4_IRQn, 2, 0);
    HAL_NVIC_EnableIRQ(UART4_IRQn);
  /* USER CODE BEGIN UART4_MspInit 1 */

  /* USER CODE END UART4_MspInit 1 */
  }
  else if(uartHandle->Instance==UART7)
  {
  /* USER CODE BEGIN UART7_MspInit 0 */

  /* USER CODE END UART7_MspInit 0 */

  /** Initializes the peripherals clock
  */
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_UART7;
    PeriphClkInitStruct.Usart234578ClockSelection = RCC_USART234578CLKSOURCE_D2PCLK1;
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
    {
      Error_Handler();
    }

    /* UART7 clock enable */
    __HAL_RCC_UART7_CLK_ENABLE();

    __HAL_RCC_GPIOE_CLK_ENABLE();
    /**UART7 GPIO Configuration
    PE7     ------> UART7_RX
    PE8     ------> UART7_TX
    */
    GPIO_InitStruct.Pin = GPIO_PIN_7|GPIO_PIN_8;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF7_UART7;
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);

    /* UART7 interrupt Init */
    HAL_NVIC_SetPriority(UART7_IRQn, 3, 0);
    HAL_NVIC_EnableIRQ(UART7_IRQn);
  /* USER CODE BEGIN UART7_MspInit 1 */

  /* USER CODE END UART7_MspInit 1 */
  }
}

void HAL_UART_MspDeInit(UART_HandleTypeDef* uartHandle)
{

  if(uartHandle->Instance==UART4)
  {
  /* USER CODE BEGIN UART4_MspDeInit 0 */

  /* USER CODE END UART4_MspDeInit 0 */
    /* Peripheral clock disable */
    __HAL_RCC_UART4_CLK_DISABLE();

    /**UART4 GPIO Configuration
    PA11     ------> UART4_RX
    PA12     ------> UART4_TX
    */
    HAL_GPIO_DeInit(GPIOA, GPIO_PIN_11|GPIO_PIN_12);

    /* UART4 interrupt Deinit */
    HAL_NVIC_DisableIRQ(UART4_IRQn);
  /* USER CODE BEGIN UART4_MspDeInit 1 */

  /* USER CODE END UART4_MspDeInit 1 */
  }
  else if(uartHandle->Instance==UART7)
  {
  /* USER CODE BEGIN UART7_MspDeInit 0 */

  /* USER CODE END UART7_MspDeInit 0 */
    /* Peripheral clock disable */
    __HAL_RCC_UART7_CLK_DISABLE();

    /**UART7 GPIO Configuration
    PE7     ------> UART7_RX
    PE8     ------> UART7_TX
    */
    HAL_GPIO_DeInit(GPIOE, GPIO_PIN_7|GPIO_PIN_8);

    /* UART7 interrupt Deinit */
    HAL_NVIC_DisableIRQ(UART7_IRQn);
  /* USER CODE BEGIN UART7_MspDeInit 1 */

  /* USER CODE END UART7_MspDeInit 1 */
  }
}

/* USER CODE BEGIN 1 */

/* USER CODE END 1 */
---- code end ----

==== Core/Inc/stm32h7xx_it.h ====
Description: Interrupt handler declarations.
---- code begin ----
/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file    stm32h7xx_it.h
  * @brief   This file contains the headers of the interrupt handlers.
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2023 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
 ******************************************************************************
  */
/* USER CODE END Header */

/* Define to prevent recursive inclusion -------------------------------------*/
#ifndef __STM32H7xx_IT_H
#define __STM32H7xx_IT_H

#ifdef __cplusplus
 extern "C" {
#endif

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */

/* USER CODE END Includes */

/* Exported types ------------------------------------------------------------*/
/* USER CODE BEGIN ET */

/* USER CODE END ET */

/* Exported constants --------------------------------------------------------*/
/* USER CODE BEGIN EC */

/* USER CODE END EC */

/* Exported macro ------------------------------------------------------------*/
/* USER CODE BEGIN EM */

/* USER CODE END EM */

/* Exported functions prototypes ---------------------------------------------*/
void NMI_Handler(void);
void HardFault_Handler(void);
void MemManage_Handler(void);
void BusFault_Handler(void);
void UsageFault_Handler(void);
void SVC_Handler(void);
void DebugMon_Handler(void);
void PendSV_Handler(void);
void SysTick_Handler(void);
void TIM1_UP_IRQHandler(void);
void TIM2_IRQHandler(void);
void TIM3_IRQHandler(void);
void UART4_IRQHandler(void);
void UART7_IRQHandler(void);
/* USER CODE BEGIN EFP */

/* USER CODE END EFP */

#ifdef __cplusplus
}
#endif

#endif /* __STM32H7xx_IT_H */
---- code end ----

==== Core/Src/stm32h7xx_it.c ====
Description: IRQ handlers for DMA/USART/Timers.
---- code begin ----
/* USER CODE BEGIN Header */
/**
 ******************************************************************************
 * @file    stm32h7xx_it.c
 * @brief   Interrupt Service Routines.
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */
/* USER CODE END Header */

/* Includes ------------------------------------------------------------------*/
#include "main.h"
#include "stm32h7xx_it.h"
/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN TD */

/* USER CODE END TD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */

/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/
/* USER CODE BEGIN PV */

/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
/* USER CODE BEGIN PFP */

/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */

/* USER CODE END 0 */

/* External variables --------------------------------------------------------*/
extern TIM_HandleTypeDef htim1;
extern TIM_HandleTypeDef htim2;
extern TIM_HandleTypeDef htim3;
extern UART_HandleTypeDef huart4;
extern UART_HandleTypeDef huart7;
/* USER CODE BEGIN EV */

/* USER CODE END EV */

/******************************************************************************/
/*           Cortex Processor Interruption and Exception Handlers          */
/******************************************************************************/
/**
  * @brief This function handles Non maskable interrupt.
  */
void NMI_Handler(void)
{
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
    while (1) {}
  /* USER CODE END NonMaskableInt_IRQn 1 */
}

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
  {
    /* USER CODE BEGIN W1_HardFault_IRQn 0 */
    /* USER CODE END W1_HardFault_IRQn 0 */
  }
}

/**
  * @brief This function handles Memory management fault.
  */
void MemManage_Handler(void)
{
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */

  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
  {
    /* USER CODE BEGIN W1_MemoryManagement_IRQn 0 */
    /* USER CODE END W1_MemoryManagement_IRQn 0 */
  }
}

/**
  * @brief This function handles Pre-fetch fault, memory access fault.
  */
void BusFault_Handler(void)
{
  /* USER CODE BEGIN BusFault_IRQn 0 */

  /* USER CODE END BusFault_IRQn 0 */
  while (1)
  {
    /* USER CODE BEGIN W1_BusFault_IRQn 0 */
    /* USER CODE END W1_BusFault_IRQn 0 */
  }
}

/**
  * @brief This function handles Undefined instruction or illegal state.
  */
void UsageFault_Handler(void)
{
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
  {
    /* USER CODE BEGIN W1_UsageFault_IRQn 0 */
    /* USER CODE END W1_UsageFault_IRQn 0 */
  }
}

/**
  * @brief This function handles System service call via SWI instruction.
  */
void SVC_Handler(void)
{
  /* USER CODE BEGIN SVCall_IRQn 0 */

  /* USER CODE END SVCall_IRQn 0 */
  /* USER CODE BEGIN SVCall_IRQn 1 */

  /* USER CODE END SVCall_IRQn 1 */
}

/**
  * @brief This function handles Debug monitor.
  */
void DebugMon_Handler(void)
{
  /* USER CODE BEGIN DebugMonitor_IRQn 0 */

  /* USER CODE END DebugMonitor_IRQn 0 */
  /* USER CODE BEGIN DebugMonitor_IRQn 1 */

  /* USER CODE END DebugMonitor_IRQn 1 */
}

/**
  * @brief This function handles Pendable request for system service.
  */
void PendSV_Handler(void)
{
  /* USER CODE BEGIN PendSV_IRQn 0 */

  /* USER CODE END PendSV_IRQn 0 */
  /* USER CODE BEGIN PendSV_IRQn 1 */

  /* USER CODE END PendSV_IRQn 1 */
}

/**
  * @brief This function handles System tick timer.
  */
void SysTick_Handler(void)
{
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
  /* USER CODE BEGIN SysTick_IRQn 1 */

  /* USER CODE END SysTick_IRQn 1 */
}

/******************************************************************************/
/* STM32H7xx Peripheral Interrupt Handlers                                    */
/* Add here the Interrupt Handlers for the used peripherals.                  */
/* For the available peripheral interrupt handler names,                      */
/* please refer to the startup file (startup_stm32h7xx.s).                    */
/******************************************************************************/

/**
  * @brief This function handles TIM1 update interrupt.
  */
void TIM1_UP_IRQHandler(void)
{
  /* USER CODE BEGIN TIM1_UP_IRQn 0 */

  /* USER CODE END TIM1_UP_IRQn 0 */
  HAL_TIM_IRQHandler(&htim1);
  /* USER CODE BEGIN TIM1_UP_IRQn 1 */

  /* USER CODE END TIM1_UP_IRQn 1 */
}

/**
  * @brief This function handles TIM2 global interrupt.
  */
void TIM2_IRQHandler(void)
{
  /* USER CODE BEGIN TIM2_IRQn 0 */

  /* USER CODE END TIM2_IRQn 0 */
  HAL_TIM_IRQHandler(&htim2);
  /* USER CODE BEGIN TIM2_IRQn 1 */

  /* USER CODE END TIM2_IRQn 1 */
}

/**
  * @brief This function handles TIM3 global interrupt.
  */
void TIM3_IRQHandler(void)
{
  /* USER CODE BEGIN TIM3_IRQn 0 */

  /* USER CODE END TIM3_IRQn 0 */
  HAL_TIM_IRQHandler(&htim3);
  /* USER CODE BEGIN TIM3_IRQn 1 */

  /* USER CODE END TIM3_IRQn 1 */
}

/**
  * @brief This function handles UART4 global interrupt.
  */
void UART4_IRQHandler(void)
{
  /* USER CODE BEGIN UART4_IRQn 0 */

  /* USER CODE END UART4_IRQn 0 */
  HAL_UART_IRQHandler(&huart4);
  /* USER CODE BEGIN UART4_IRQn 1 */

  /* USER CODE END UART4_IRQn 1 */
}

/**
  * @brief This function handles UART7 global interrupt.
  */
void UART7_IRQHandler(void)
{
  /* USER CODE BEGIN UART7_IRQn 0 */

  /* USER CODE END UART7_IRQn 0 */
  HAL_UART_IRQHandler(&huart7);
  /* USER CODE BEGIN UART7_IRQn 1 */

  /* USER CODE END UART7_IRQn 1 */
}

/* USER CODE BEGIN 1 */

/* USER CODE END 1 */
---- code end ----

==== Core/Inc/stm32h7xx_hal_conf.h ====
Description: HAL module enable list and core configuration.
---- code begin ----
/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file    stm32h7xx_hal_conf.h
  * @author  MCD Application Team
  * @brief   HAL configuration file.
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2017 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* USER CODE END Header */
/* Define to prevent recursive inclusion -------------------------------------*/
#ifndef STM32H7xx_HAL_CONF_H
#define STM32H7xx_HAL_CONF_H

#ifdef __cplusplus
 extern "C" {
#endif

/* Exported types ------------------------------------------------------------*/
/* Exported constants --------------------------------------------------------*/

/* ########################## Module Selection ############################## */
/**
  * @brief This is the list of modules to be used in the HAL driver
  */
#define HAL_MODULE_ENABLED

  /* #define HAL_ADC_MODULE_ENABLED   */
/* #define HAL_FDCAN_MODULE_ENABLED   */
/* #define HAL_FMAC_MODULE_ENABLED   */
/* #define HAL_CEC_MODULE_ENABLED   */
/* #define HAL_COMP_MODULE_ENABLED   */
/* #define HAL_CORDIC_MODULE_ENABLED   */
/* #define HAL_CRC_MODULE_ENABLED   */
/* #define HAL_CRYP_MODULE_ENABLED   */
/* #define HAL_DAC_MODULE_ENABLED   */
/* #define HAL_DCMI_MODULE_ENABLED   */
/* #define HAL_DMA2D_MODULE_ENABLED   */
/* #define HAL_ETH_MODULE_ENABLED   */
/* #define HAL_NAND_MODULE_ENABLED   */
/* #define HAL_NOR_MODULE_ENABLED   */
/* #define HAL_OTFDEC_MODULE_ENABLED   */
/* #define HAL_SRAM_MODULE_ENABLED   */
/* #define HAL_SDRAM_MODULE_ENABLED   */
/* #define HAL_HASH_MODULE_ENABLED   */
/* #define HAL_HRTIM_MODULE_ENABLED   */
/* #define HAL_HSEM_MODULE_ENABLED   */
/* #define HAL_GFXMMU_MODULE_ENABLED   */
/* #define HAL_JPEG_MODULE_ENABLED   */
/* #define HAL_OPAMP_MODULE_ENABLED   */
/* #define HAL_OSPI_MODULE_ENABLED   */
/* #define HAL_OSPI_MODULE_ENABLED   */
/* #define HAL_I2S_MODULE_ENABLED   */
/* #define HAL_SMBUS_MODULE_ENABLED   */
/* #define HAL_IWDG_MODULE_ENABLED   */
/* #define HAL_LPTIM_MODULE_ENABLED   */
/* #define HAL_LTDC_MODULE_ENABLED   */
/* #define HAL_QSPI_MODULE_ENABLED   */
/* #define HAL_RAMECC_MODULE_ENABLED   */
/* #define HAL_RNG_MODULE_ENABLED   */
/* #define HAL_RTC_MODULE_ENABLED   */
/* #define HAL_SAI_MODULE_ENABLED   */
/* #define HAL_SD_MODULE_ENABLED   */
/* #define HAL_MMC_MODULE_ENABLED   */
/* #define HAL_SPDIFRX_MODULE_ENABLED   */
/* #define HAL_SPI_MODULE_ENABLED   */
/* #define HAL_SWPMI_MODULE_ENABLED   */
#define HAL_TIM_MODULE_ENABLED
#define HAL_UART_MODULE_ENABLED
/* #define HAL_USART_MODULE_ENABLED   */
/* #define HAL_IRDA_MODULE_ENABLED   */
/* #define HAL_SMARTCARD_MODULE_ENABLED   */
/* #define HAL_WWDG_MODULE_ENABLED   */
/* #define HAL_PCD_MODULE_ENABLED   */
/* #define HAL_HCD_MODULE_ENABLED   */
/* #define HAL_DFSDM_MODULE_ENABLED   */
/* #define HAL_DSI_MODULE_ENABLED   */
/* #define HAL_JPEG_MODULE_ENABLED   */
/* #define HAL_MDIOS_MODULE_ENABLED   */
/* #define HAL_PSSI_MODULE_ENABLED   */
/* #define HAL_DTS_MODULE_ENABLED   */
#define HAL_GPIO_MODULE_ENABLED
#define HAL_DMA_MODULE_ENABLED
#define HAL_MDMA_MODULE_ENABLED
#define HAL_RCC_MODULE_ENABLED
#define HAL_FLASH_MODULE_ENABLED
#define HAL_EXTI_MODULE_ENABLED
#define HAL_PWR_MODULE_ENABLED
#define HAL_I2C_MODULE_ENABLED
#define HAL_CORTEX_MODULE_ENABLED
#define HAL_HSEM_MODULE_ENABLED

/* ########################## Oscillator Values adaptation ####################*/
/**
  * @brief Adjust the value of External High Speed oscillator (HSE) used in your application.
  *        This value is used by the RCC HAL module to compute the system frequency
  *        (when HSE is used as system clock source, directly or through the PLL).
  */
#if !defined  (HSE_VALUE)
#define HSE_VALUE    (32000000UL) /*!< Value of the External oscillator in Hz : FPGA case fixed to 60MHZ */
#endif /* HSE_VALUE */

#if !defined  (HSE_STARTUP_TIMEOUT)
  #define HSE_STARTUP_TIMEOUT    (100UL)   /*!< Time out for HSE start up, in ms */
#endif /* HSE_STARTUP_TIMEOUT */

/**
  * @brief Internal  oscillator (CSI) default value.
  *        This value is the default CSI value after Reset.
  */
#if !defined  (CSI_VALUE)
  #define CSI_VALUE    (4000000UL) /*!< Value of the Internal oscillator in Hz*/
#endif /* CSI_VALUE */

/**
  * @brief Internal High Speed oscillator (HSI) value.
  *        This value is used by the RCC HAL module to compute the system frequency
  *        (when HSI is used as system clock source, directly or through the PLL).
  */
#if !defined  (HSI_VALUE)
  #define HSI_VALUE    (64000000UL) /*!< Value of the Internal oscillator in Hz*/
#endif /* HSI_VALUE */

/**
  * @brief External Low Speed oscillator (LSE) value.
  *        This value is used by the UART, RTC HAL module to compute the system frequency
  */
#if !defined  (LSE_VALUE)
  #define LSE_VALUE    (32768UL) /*!< Value of the External oscillator in Hz*/
#endif /* LSE_VALUE */

#if !defined  (LSE_STARTUP_TIMEOUT)
  #define LSE_STARTUP_TIMEOUT    (5000UL)   /*!< Time out for LSE start up, in ms */
#endif /* LSE_STARTUP_TIMEOUT */

#if !defined  (LSI_VALUE)
  #define LSI_VALUE  (32000UL)              /*!< LSI Typical Value in Hz*/
#endif /* LSI_VALUE */                      /*!< Value of the Internal Low Speed oscillator in Hz
                                              The real value may vary depending on the variations
                                              in voltage and temperature.*/

/**
  * @brief External clock source for I2S peripheral
  *        This value is used by the I2S HAL module to compute the I2S clock source
  *        frequency, this source is inserted directly through I2S_CKIN pad.
  */
#if !defined  (EXTERNAL_CLOCK_VALUE)
  #define EXTERNAL_CLOCK_VALUE    12288000UL /*!< Value of the External clock in Hz*/
#endif /* EXTERNAL_CLOCK_VALUE */

/* Tip: To avoid modifying this file each time you need to use different HSE,
   ===  you can define the HSE value in your toolchain compiler preprocessor. */

/* ########################### System Configuration ######################### */
/**
  * @brief This is the HAL system configuration section
  */
#define  VDD_VALUE                    (3300UL) /*!< Value of VDD in mv */
#define  TICK_INT_PRIORITY            (15UL) /*!< tick interrupt priority */
#define  USE_RTOS                     0
#define  USE_SD_TRANSCEIVER           0U               /*!< use uSD Transceiver */
#define  USE_SPI_CRC	              0U               /*!< use CRC in SPI */

#define  USE_HAL_ADC_REGISTER_CALLBACKS     0U /* ADC register callback disabled     */
#define  USE_HAL_CEC_REGISTER_CALLBACKS     0U /* CEC register callback disabled     */
#define  USE_HAL_COMP_REGISTER_CALLBACKS    0U /* COMP register callback disabled    */
#define  USE_HAL_CORDIC_REGISTER_CALLBACKS  0U /* CORDIC register callback disabled  */
#define  USE_HAL_CRYP_REGISTER_CALLBACKS    0U /* CRYP register callback disabled    */
#define  USE_HAL_DAC_REGISTER_CALLBACKS     0U /* DAC register callback disabled     */
#define  USE_HAL_DCMI_REGISTER_CALLBACKS    0U /* DCMI register callback disabled    */
#define  USE_HAL_DFSDM_REGISTER_CALLBACKS   0U /* DFSDM register callback disabled   */
#define  USE_HAL_DMA2D_REGISTER_CALLBACKS   0U /* DMA2D register callback disabled   */
#define  USE_HAL_DSI_REGISTER_CALLBACKS     0U /* DSI register callback disabled     */
#define  USE_HAL_DTS_REGISTER_CALLBACKS     0U /* DTS register callback disabled     */
#define  USE_HAL_ETH_REGISTER_CALLBACKS     0U /* ETH register callback disabled     */
#define  USE_HAL_FDCAN_REGISTER_CALLBACKS   0U /* FDCAN register callback disabled   */
#define  USE_HAL_FMAC_REGISTER_CALLBACKS    0U /* FMAC register callback disabled  */
#define  USE_HAL_NAND_REGISTER_CALLBACKS    0U /* NAND register callback disabled    */
#define  USE_HAL_NOR_REGISTER_CALLBACKS     0U /* NOR register callback disabled     */
#define  USE_HAL_SDRAM_REGISTER_CALLBACKS   0U /* SDRAM register callback disabled   */
#define  USE_HAL_SRAM_REGISTER_CALLBACKS    0U /* SRAM register callback disabled    */
#define  USE_HAL_HASH_REGISTER_CALLBACKS    0U /* HASH register callback disabled    */
#define  USE_HAL_HCD_REGISTER_CALLBACKS     0U /* HCD register callback disabled     */
#define  USE_HAL_GFXMMU_REGISTER_CALLBACKS  0U /* GFXMMU register callback disabled  */
#define  USE_HAL_HRTIM_REGISTER_CALLBACKS   0U /* HRTIM register callback disabled   */
#define  USE_HAL_I2C_REGISTER_CALLBACKS     0U /* I2C register callback disabled     */
#define  USE_HAL_I2S_REGISTER_CALLBACKS     0U /* I2S register callback disabled     */
#define  USE_HAL_IRDA_REGISTER_CALLBACKS    0U /* IRDA register callback disabled    */
#define  USE_HAL_JPEG_REGISTER_CALLBACKS    0U /* JPEG register callback disabled    */
#define  USE_HAL_LPTIM_REGISTER_CALLBACKS   0U /* LPTIM register callback disabled   */
#define  USE_HAL_LTDC_REGISTER_CALLBACKS    0U /* LTDC register callback disabled    */
#define  USE_HAL_MDIOS_REGISTER_CALLBACKS   0U /* MDIO register callback disabled    */
#define  USE_HAL_MMC_REGISTER_CALLBACKS     0U /* MMC register callback disabled     */
#define  USE_HAL_OPAMP_REGISTER_CALLBACKS   0U /* MDIO register callback disabled    */
#define  USE_HAL_OSPI_REGISTER_CALLBACKS    0U /* OSPI register callback disabled    */
#define  USE_HAL_OTFDEC_REGISTER_CALLBACKS  0U /* OTFDEC register callback disabled  */
#define  USE_HAL_PCD_REGISTER_CALLBACKS     0U /* PCD register callback disabled     */
#define  USE_HAL_QSPI_REGISTER_CALLBACKS    0U /* QSPI register callback disabled    */
#define  USE_HAL_RNG_REGISTER_CALLBACKS     0U /* RNG register callback disabled     */
#define  USE_HAL_RTC_REGISTER_CALLBACKS     0U /* RTC register callback disabled     */
#define  USE_HAL_SAI_REGISTER_CALLBACKS     0U /* SAI register callback disabled     */
#define  USE_HAL_SD_REGISTER_CALLBACKS      0U /* SD register callback disabled      */
#define  USE_HAL_SMARTCARD_REGISTER_CALLBACKS  0U /* SMARTCARD register callback disabled */
#define  USE_HAL_SPDIFRX_REGISTER_CALLBACKS 0U /* SPDIFRX register callback disabled */
#define  USE_HAL_SMBUS_REGISTER_CALLBACKS   0U /* SMBUS register callback disabled   */
#define  USE_HAL_SPI_REGISTER_CALLBACKS     0U /* SPI register callback disabled     */
#define  USE_HAL_SWPMI_REGISTER_CALLBACKS   0U /* SWPMI register callback disabled   */
#define  USE_HAL_TIM_REGISTER_CALLBACKS     0U /* TIM register callback disabled     */
#define  USE_HAL_UART_REGISTER_CALLBACKS    0U /* UART register callback disabled    */
#define  USE_HAL_USART_REGISTER_CALLBACKS   0U /* USART register callback disabled   */
#define  USE_HAL_WWDG_REGISTER_CALLBACKS    0U /* WWDG register callback disabled    */

/* ########################### Ethernet Configuration ######################### */
#define ETH_TX_DESC_CNT         4  /* number of Ethernet Tx DMA descriptors */
#define ETH_RX_DESC_CNT         4  /* number of Ethernet Rx DMA descriptors */

#define ETH_MAC_ADDR0    (0x02UL)
#define ETH_MAC_ADDR1    (0x00UL)
#define ETH_MAC_ADDR2    (0x00UL)
#define ETH_MAC_ADDR3    (0x00UL)
#define ETH_MAC_ADDR4    (0x00UL)
#define ETH_MAC_ADDR5    (0x00UL)

/* ########################## Assert Selection ############################## */
/**
  * @brief Uncomment the line below to expanse the "assert_param" macro in the
  *        HAL drivers code
  */
/* #define USE_FULL_ASSERT    1U */

/* Includes ------------------------------------------------------------------*/
/**
  * @brief Include module's header file
  */

#ifdef HAL_RCC_MODULE_ENABLED
  #include "stm32h7xx_hal_rcc.h"
#endif /* HAL_RCC_MODULE_ENABLED */

#ifdef HAL_GPIO_MODULE_ENABLED
  #include "stm32h7xx_hal_gpio.h"
#endif /* HAL_GPIO_MODULE_ENABLED */

#ifdef HAL_DMA_MODULE_ENABLED
  #include "stm32h7xx_hal_dma.h"
#endif /* HAL_DMA_MODULE_ENABLED */

#ifdef HAL_MDMA_MODULE_ENABLED
 #include "stm32h7xx_hal_mdma.h"
#endif /* HAL_MDMA_MODULE_ENABLED */

#ifdef HAL_HASH_MODULE_ENABLED
  #include "stm32h7xx_hal_hash.h"
#endif /* HAL_HASH_MODULE_ENABLED */

#ifdef HAL_DCMI_MODULE_ENABLED
  #include "stm32h7xx_hal_dcmi.h"
#endif /* HAL_DCMI_MODULE_ENABLED */

#ifdef HAL_DMA2D_MODULE_ENABLED
  #include "stm32h7xx_hal_dma2d.h"
#endif /* HAL_DMA2D_MODULE_ENABLED */

#ifdef HAL_DSI_MODULE_ENABLED
  #include "stm32h7xx_hal_dsi.h"
#endif /* HAL_DSI_MODULE_ENABLED */

#ifdef HAL_DFSDM_MODULE_ENABLED
  #include "stm32h7xx_hal_dfsdm.h"
#endif /* HAL_DFSDM_MODULE_ENABLED */

#ifdef HAL_DTS_MODULE_ENABLED
 #include "stm32h7xx_hal_dts.h"
#endif /* HAL_DTS_MODULE_ENABLED */

#ifdef HAL_ETH_MODULE_ENABLED
  #include "stm32h7xx_hal_eth.h"
#endif /* HAL_ETH_MODULE_ENABLED */

#ifdef HAL_EXTI_MODULE_ENABLED
  #include "stm32h7xx_hal_exti.h"
#endif /* HAL_EXTI_MODULE_ENABLED */

#ifdef HAL_CORTEX_MODULE_ENABLED
  #include "stm32h7xx_hal_cortex.h"
#endif /* HAL_CORTEX_MODULE_ENABLED */

#ifdef HAL_ADC_MODULE_ENABLED
  #include "stm32h7xx_hal_adc.h"
#endif /* HAL_ADC_MODULE_ENABLED */

#ifdef HAL_FDCAN_MODULE_ENABLED
  #include "stm32h7xx_hal_fdcan.h"
#endif /* HAL_FDCAN_MODULE_ENABLED */

#ifdef HAL_CEC_MODULE_ENABLED
  #include "stm32h7xx_hal_cec.h"
#endif /* HAL_CEC_MODULE_ENABLED */

#ifdef HAL_COMP_MODULE_ENABLED
  #include "stm32h7xx_hal_comp.h"
#endif /* HAL_COMP_MODULE_ENABLED */

#ifdef HAL_CORDIC_MODULE_ENABLED
  #include "stm32h7xx_hal_cordic.h"
#endif /* HAL_CORDIC_MODULE_ENABLED */

#ifdef HAL_CRC_MODULE_ENABLED
  #include "stm32h7xx_hal_crc.h"
#endif /* HAL_CRC_MODULE_ENABLED */

#ifdef HAL_CRYP_MODULE_ENABLED
  #include "stm32h7xx_hal_cryp.h"
#endif /* HAL_CRYP_MODULE_ENABLED */

#ifdef HAL_DAC_MODULE_ENABLED
  #include "stm32h7xx_hal_dac.h"
#endif /* HAL_DAC_MODULE_ENABLED */

#ifdef HAL_FLASH_MODULE_ENABLED
  #include "stm32h7xx_hal_flash.h"
#endif /* HAL_FLASH_MODULE_ENABLED */

#ifdef HAL_GFXMMU_MODULE_ENABLED
  #include "stm32h7xx_hal_gfxmmu.h"
#endif /* HAL_GFXMMU_MODULE_ENABLED */

#ifdef HAL_FMAC_MODULE_ENABLED
  #include "stm32h7xx_hal_fmac.h"
#endif /* HAL_FMAC_MODULE_ENABLED */

#ifdef HAL_HRTIM_MODULE_ENABLED
  #include "stm32h7xx_hal_hrtim.h"
#endif /* HAL_HRTIM_MODULE_ENABLED */

#ifdef HAL_HSEM_MODULE_ENABLED
  #include "stm32h7xx_hal_hsem.h"
#endif /* HAL_HSEM_MODULE_ENABLED */

#ifdef HAL_SRAM_MODULE_ENABLED
  #include "stm32h7xx_hal_sram.h"
#endif /* HAL_SRAM_MODULE_ENABLED */

#ifdef HAL_NOR_MODULE_ENABLED
  #include "stm32h7xx_hal_nor.h"
#endif /* HAL_NOR_MODULE_ENABLED */

#ifdef HAL_NAND_MODULE_ENABLED
  #include "stm32h7xx_hal_nand.h"
#endif /* HAL_NAND_MODULE_ENABLED */

#ifdef HAL_I2C_MODULE_ENABLED
 #include "stm32h7xx_hal_i2c.h"
#endif /* HAL_I2C_MODULE_ENABLED */

#ifdef HAL_I2S_MODULE_ENABLED
 #include "stm32h7xx_hal_i2s.h"
#endif /* HAL_I2S_MODULE_ENABLED */

#ifdef HAL_IWDG_MODULE_ENABLED
 #include "stm32h7xx_hal_iwdg.h"
#endif /* HAL_IWDG_MODULE_ENABLED */

#ifdef HAL_JPEG_MODULE_ENABLED
 #include "stm32h7xx_hal_jpeg.h"
#endif /* HAL_JPEG_MODULE_ENABLED */

#ifdef HAL_MDIOS_MODULE_ENABLED
 #include "stm32h7xx_hal_mdios.h"
#endif /* HAL_MDIOS_MODULE_ENABLED */

#ifdef HAL_MMC_MODULE_ENABLED
 #include "stm32h7xx_hal_mmc.h"
#endif /* HAL_MMC_MODULE_ENABLED */

#ifdef HAL_LPTIM_MODULE_ENABLED
#include "stm32h7xx_hal_lptim.h"
#endif /* HAL_LPTIM_MODULE_ENABLED */

#ifdef HAL_LTDC_MODULE_ENABLED
#include "stm32h7xx_hal_ltdc.h"
#endif /* HAL_LTDC_MODULE_ENABLED */

#ifdef HAL_OPAMP_MODULE_ENABLED
#include "stm32h7xx_hal_opamp.h"
#endif /* HAL_OPAMP_MODULE_ENABLED */

#ifdef HAL_OSPI_MODULE_ENABLED
 #include "stm32h7xx_hal_ospi.h"
#endif /* HAL_OSPI_MODULE_ENABLED */

#ifdef HAL_OTFDEC_MODULE_ENABLED
#include "stm32h7xx_hal_otfdec.h"
#endif /* HAL_OTFDEC_MODULE_ENABLED */

#ifdef HAL_PSSI_MODULE_ENABLED
 #include "stm32h7xx_hal_pssi.h"
#endif /* HAL_PSSI_MODULE_ENABLED */

#ifdef HAL_PWR_MODULE_ENABLED
 #include "stm32h7xx_hal_pwr.h"
#endif /* HAL_PWR_MODULE_ENABLED */

#ifdef HAL_QSPI_MODULE_ENABLED
 #include "stm32h7xx_hal_qspi.h"
#endif /* HAL_QSPI_MODULE_ENABLED */

#ifdef HAL_RAMECC_MODULE_ENABLED
 #include "stm32h7xx_hal_ramecc.h"
#endif /* HAL_RAMECC_MODULE_ENABLED */

#ifdef HAL_RNG_MODULE_ENABLED
 #include "stm32h7xx_hal_rng.h"
#endif /* HAL_RNG_MODULE_ENABLED */

#ifdef HAL_RTC_MODULE_ENABLED
 #include "stm32h7xx_hal_rtc.h"
#endif /* HAL_RTC_MODULE_ENABLED */

#ifdef HAL_SAI_MODULE_ENABLED
 #include "stm32h7xx_hal_sai.h"
#endif /* HAL_SAI_MODULE_ENABLED */

#ifdef HAL_SD_MODULE_ENABLED
 #include "stm32h7xx_hal_sd.h"
#endif /* HAL_SD_MODULE_ENABLED */

#ifdef HAL_SDRAM_MODULE_ENABLED
 #include "stm32h7xx_hal_sdram.h"
#endif /* HAL_SDRAM_MODULE_ENABLED */

#ifdef HAL_SPI_MODULE_ENABLED
 #include "stm32h7xx_hal_spi.h"
#endif /* HAL_SPI_MODULE_ENABLED */

#ifdef HAL_SPDIFRX_MODULE_ENABLED
 #include "stm32h7xx_hal_spdifrx.h"
#endif /* HAL_SPDIFRX_MODULE_ENABLED */

#ifdef HAL_SWPMI_MODULE_ENABLED
 #include "stm32h7xx_hal_swpmi.h"
#endif /* HAL_SWPMI_MODULE_ENABLED */

#ifdef HAL_TIM_MODULE_ENABLED
 #include "stm32h7xx_hal_tim.h"
#endif /* HAL_TIM_MODULE_ENABLED */

#ifdef HAL_UART_MODULE_ENABLED
 #include "stm32h7xx_hal_uart.h"
#endif /* HAL_UART_MODULE_ENABLED */

#ifdef HAL_USART_MODULE_ENABLED
 #include "stm32h7xx_hal_usart.h"
#endif /* HAL_USART_MODULE_ENABLED */

#ifdef HAL_IRDA_MODULE_ENABLED
 #include "stm32h7xx_hal_irda.h"
#endif /* HAL_IRDA_MODULE_ENABLED */

#ifdef HAL_SMARTCARD_MODULE_ENABLED
 #include "stm32h7xx_hal_smartcard.h"
#endif /* HAL_SMARTCARD_MODULE_ENABLED */

#ifdef HAL_SMBUS_MODULE_ENABLED
 #include "stm32h7xx_hal_smbus.h"
#endif /* HAL_SMBUS_MODULE_ENABLED */

#ifdef HAL_WWDG_MODULE_ENABLED
 #include "stm32h7xx_hal_wwdg.h"
#endif /* HAL_WWDG_MODULE_ENABLED */

#ifdef HAL_PCD_MODULE_ENABLED
 #include "stm32h7xx_hal_pcd.h"
#endif /* HAL_PCD_MODULE_ENABLED */

#ifdef HAL_HCD_MODULE_ENABLED
 #include "stm32h7xx_hal_hcd.h"
#endif /* HAL_HCD_MODULE_ENABLED */

/* Exported macro ------------------------------------------------------------*/
#ifdef  USE_FULL_ASSERT
/**
  * @brief  The assert_param macro is used for function's parameters check.
  * @param  expr: If expr is false, it calls assert_failed function
  *         which reports the name of the source file and the source
  *         line number of the call that failed.
  *         If expr is true, it returns no value.
  * @retval None
  */
  #define assert_param(expr) ((expr) ? (void)0U : assert_failed((uint8_t *)__FILE__, __LINE__))
/* Exported functions ------------------------------------------------------- */
  void assert_failed(uint8_t *file, uint32_t line);
#else
  #define assert_param(expr) ((void)0U)
#endif /* USE_FULL_ASSERT */

#ifdef __cplusplus
}
#endif

#endif /* STM32H7xx_HAL_CONF_H */
---- code end ----

==== Core/Src/system_stm32h7xx.c ====
Description: System clock setup and low-level system init.
---- code begin ----
/**
  ******************************************************************************
  * @file    system_stm32h7xx.c
  * @author  MCD Application Team
  * @brief   CMSIS Cortex-Mx Device Peripheral Access Layer System Source File.
  *
  *   This file provides two functions and one global variable to be called from
  *   user application:
  *      - SystemInit(): This function is called at startup just after reset and
  *                      before branch to main program. This call is made inside
  *                      the "startup_stm32h7xx.s" file.
  *
  *      - SystemCoreClock variable: Contains the core clock, it can be used
  *                                  by the user application to setup the SysTick
  *                                  timer or configure other parameters.
  *
  *      - SystemCoreClockUpdate(): Updates the variable SystemCoreClock and must
  *                                 be called whenever the core clock is changed
  *                                 during program execution.
  *
  *
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2017 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */

/** @addtogroup CMSIS
  * @{
  */

/** @addtogroup stm32h7xx_system
  * @{
  */

/** @addtogroup STM32H7xx_System_Private_Includes
  * @{
  */

#include "stm32h7xx.h"
#include <math.h>

#if !defined  (HSE_VALUE)
#define HSE_VALUE    ((uint32_t)25000000) /*!< Value of the External oscillator in Hz */
#endif /* HSE_VALUE */

#if !defined  (CSI_VALUE)
  #define CSI_VALUE    ((uint32_t)4000000) /*!< Value of the Internal oscillator in Hz*/
#endif /* CSI_VALUE */

#if !defined  (HSI_VALUE)
  #define HSI_VALUE    ((uint32_t)64000000) /*!< Value of the Internal oscillator in Hz*/
#endif /* HSI_VALUE */


/**
  * @}
  */

/** @addtogroup STM32H7xx_System_Private_TypesDefinitions
  * @{
  */

/**
  * @}
  */

/** @addtogroup STM32H7xx_System_Private_Defines
  * @{
  */

/************************* Miscellaneous Configuration ************************/
/*!< Uncomment the following line if you need to use initialized data in D2 domain SRAM (AHB SRAM) */
/* #define DATA_IN_D2_SRAM */

/* Note: Following vector table addresses must be defined in line with linker
         configuration. */
/*!< Uncomment the following line if you need to relocate the vector table
     anywhere in FLASH BANK1 or AXI SRAM, else the vector table is kept at the automatic
     remap of boot address selected */
/* #define USER_VECT_TAB_ADDRESS */

#if defined(USER_VECT_TAB_ADDRESS)
#if defined(DUAL_CORE) && defined(CORE_CM4)
/*!< Uncomment the following line if you need to relocate your vector Table
     in D2 AXI SRAM else user remap will be done in FLASH BANK2. */
/* #define VECT_TAB_SRAM */
#if defined(VECT_TAB_SRAM)
#define VECT_TAB_BASE_ADDRESS   D2_AXISRAM_BASE   /*!< Vector Table base address field.
                                                       This value must be a multiple of 0x400. */
#define VECT_TAB_OFFSET         0x00000000U       /*!< Vector Table base offset field.
                                                       This value must be a multiple of 0x400. */
#else
#define VECT_TAB_BASE_ADDRESS   FLASH_BANK2_BASE  /*!< Vector Table base address field.
                                                       This value must be a multiple of 0x400. */
#define VECT_TAB_OFFSET         0x00000000U       /*!< Vector Table base offset field.
                                                       This value must be a multiple of 0x400. */
#endif /* VECT_TAB_SRAM */
#else
/*!< Uncomment the following line if you need to relocate your vector Table
     in D1 AXI SRAM else user remap will be done in FLASH BANK1. */
/* #define VECT_TAB_SRAM */
#if defined(VECT_TAB_SRAM)
#define VECT_TAB_BASE_ADDRESS   D1_AXISRAM_BASE   /*!< Vector Table base address field.
                                                       This value must be a multiple of 0x400. */
#define VECT_TAB_OFFSET         0x00000000U       /*!< Vector Table base offset field.
                                                       This value must be a multiple of 0x400. */
#else
#define VECT_TAB_BASE_ADDRESS   FLASH_BANK1_BASE  /*!< Vector Table base address field.
                                                       This value must be a multiple of 0x400. */
#define VECT_TAB_OFFSET         0x00000000U       /*!< Vector Table base offset field.
                                                       This value must be a multiple of 0x400. */
#endif /* VECT_TAB_SRAM */
#endif /* DUAL_CORE && CORE_CM4 */
#endif /* USER_VECT_TAB_ADDRESS */
/******************************************************************************/

/**
  * @}
  */

/** @addtogroup STM32H7xx_System_Private_Macros
  * @{
  */

/**
  * @}
  */

/** @addtogroup STM32H7xx_System_Private_Variables
  * @{
  */
  /* This variable is updated in three ways:
      1) by calling CMSIS function SystemCoreClockUpdate()
      2) by calling HAL API function HAL_RCC_GetHCLKFreq()
      3) each time HAL_RCC_ClockConfig() is called to configure the system clock frequency
         Note: If you use this function to configure the system clock; then there
               is no need to call the 2 first functions listed above, since SystemCoreClock
               variable is updated automatically.
  */
  uint32_t SystemCoreClock = 64000000;
  uint32_t SystemD2Clock = 64000000;
  const  uint8_t D1CorePrescTable[16] = {0, 0, 0, 0, 1, 2, 3, 4, 1, 2, 3, 4, 6, 7, 8, 9};

/**
  * @}
  */

/** @addtogroup STM32H7xx_System_Private_FunctionPrototypes
  * @{
  */

/**
  * @}
  */

/** @addtogroup STM32H7xx_System_Private_Functions
  * @{
  */

/**
  * @brief  Setup the microcontroller system
  *         Initialize the FPU setting and  vector table location
  *         configuration.
  * @param  None
  * @retval None
  */
void SystemInit (void)
{
#if defined (DATA_IN_D2_SRAM)
 __IO uint32_t tmpreg;
#endif /* DATA_IN_D2_SRAM */

  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << (10*2))|(3UL << (11*2)));  /* set CP10 and CP11 Full Access */
  #endif
  /* Reset the RCC clock configuration to the default reset state ------------*/

   /* Increasing the CPU frequency */
  if(FLASH_LATENCY_DEFAULT  > (READ_BIT((FLASH->ACR), FLASH_ACR_LATENCY)))
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    MODIFY_REG(FLASH->ACR, FLASH_ACR_LATENCY, (uint32_t)(FLASH_LATENCY_DEFAULT));
  }

  /* Set HSION bit */
  RCC->CR |= RCC_CR_HSION;

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;

  /* Reset HSEON, HSECSSON, CSION, HSI48ON, CSIKERON, PLL1ON, PLL2ON and PLL3ON bits */
  RCC->CR &= 0xEAF6ED7FU;

   /* Decreasing the number of wait states because of lower CPU frequency */
  if(FLASH_LATENCY_DEFAULT  < (READ_BIT((FLASH->ACR), FLASH_ACR_LATENCY)))
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    MODIFY_REG(FLASH->ACR, FLASH_ACR_LATENCY, (uint32_t)(FLASH_LATENCY_DEFAULT));
  }

#if defined(D3_SRAM_BASE)
  /* Reset D1CFGR register */
  RCC->D1CFGR = 0x00000000;

  /* Reset D2CFGR register */
  RCC->D2CFGR = 0x00000000;

  /* Reset D3CFGR register */
  RCC->D3CFGR = 0x00000000;
#else
  /* Reset CDCFGR1 register */
  RCC->CDCFGR1 = 0x00000000;

  /* Reset CDCFGR2 register */
  RCC->CDCFGR2 = 0x00000000;

  /* Reset SRDCFGR register */
  RCC->SRDCFGR = 0x00000000;
#endif
  /* Reset PLLCKSELR register */
  RCC->PLLCKSELR = 0x02020200;

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x01FF0000;
  /* Reset PLL1DIVR register */
  RCC->PLL1DIVR = 0x01010280;
  /* Reset PLL1FRACR register */
  RCC->PLL1FRACR = 0x00000000;

  /* Reset PLL2DIVR register */
  RCC->PLL2DIVR = 0x01010280;

  /* Reset PLL2FRACR register */

  RCC->PLL2FRACR = 0x00000000;
  /* Reset PLL3DIVR register */
  RCC->PLL3DIVR = 0x01010280;

  /* Reset PLL3FRACR register */
  RCC->PLL3FRACR = 0x00000000;

  /* Reset HSEBYP bit */
  RCC->CR &= 0xFFFBFFFFU;

  /* Disable all interrupts */
  RCC->CIER = 0x00000000;

#if (STM32H7_DEV_ID == 0x450UL)
  /* dual core CM7 or single core line */
  if((DBGMCU->IDCODE & 0xFFFF0000U) < 0x20000000U)
  {
    /* if stm32h7 revY*/
    /* Change  the switch matrix read issuing capability to 1 for the AXI SRAM target (Target 7) */
    *((__IO uint32_t*)0x51008108) = 0x000000001U;
  }
#endif /* STM32H7_DEV_ID */

#if defined(DATA_IN_D2_SRAM)
  /* in case of initialized data in D2 SRAM (AHB SRAM), enable the D2 SRAM clock (AHB SRAM clock) */
#if defined(RCC_AHB2ENR_D2SRAM3EN)
  RCC->AHB2ENR |= (RCC_AHB2ENR_D2SRAM1EN | RCC_AHB2ENR_D2SRAM2EN | RCC_AHB2ENR_D2SRAM3EN);
#elif defined(RCC_AHB2ENR_D2SRAM2EN)
  RCC->AHB2ENR |= (RCC_AHB2ENR_D2SRAM1EN | RCC_AHB2ENR_D2SRAM2EN);
#else
  RCC->AHB2ENR |= (RCC_AHB2ENR_AHBSRAM1EN | RCC_AHB2ENR_AHBSRAM2EN);
#endif /* RCC_AHB2ENR_D2SRAM3EN */

  tmpreg = RCC->AHB2ENR;
  (void) tmpreg;
#endif /* DATA_IN_D2_SRAM */

#if defined(DUAL_CORE) && defined(CORE_CM4)
  /* Configure the Vector Table location add offset address for cortex-M4 ------------------*/
#if defined(USER_VECT_TAB_ADDRESS)
  SCB->VTOR = VECT_TAB_BASE_ADDRESS | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal D2 AXI-RAM or in Internal FLASH */
#endif /* USER_VECT_TAB_ADDRESS */

#else
  /*
   * Disable the FMC bank1 (enabled after reset).
   * This, prevents CPU speculation access on this bank which blocks the use of FMC during
   * 24us. During this time the others FMC master (such as LTDC) cannot use it!
   */
  FMC_Bank1_R->BTCR[0] = 0x000030D2;

  /* Configure the Vector Table location -------------------------------------*/
#if defined(USER_VECT_TAB_ADDRESS)
  SCB->VTOR = VECT_TAB_BASE_ADDRESS | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal D1 AXI-RAM or in Internal FLASH */
#endif /* USER_VECT_TAB_ADDRESS */

#endif /*DUAL_CORE && CORE_CM4*/
}

/**
   * @brief  Update SystemCoreClock variable according to Clock Register Values.
  *         The SystemCoreClock variable contains the core clock , it can
  *         be used by the user application to setup the SysTick timer or configure
  *         other parameters.
  *
  * @note   Each time the core clock changes, this function must be called
  *         to update SystemCoreClock variable value. Otherwise, any configuration
  *         based on this variable will be incorrect.
  *
  * @note   - The system frequency computed by this function is not the real
  *           frequency in the chip. It is calculated based on the predefined
  *           constant and the selected clock source:
  *
  *           - If SYSCLK source is CSI, SystemCoreClock will contain the CSI_VALUE(*)
  *           - If SYSCLK source is HSI, SystemCoreClock will contain the HSI_VALUE(**)
  *           - If SYSCLK source is HSE, SystemCoreClock will contain the HSE_VALUE(***)
  *           - If SYSCLK source is PLL, SystemCoreClock will contain the CSI_VALUE(*),
  *             HSI_VALUE(**) or HSE_VALUE(***) multiplied/divided by the PLL factors.
  *
  *         (*) CSI_VALUE is a constant defined in stm32h7xx_hal.h file (default value
  *             4 MHz) but the real value may vary depending on the variations
  *             in voltage and temperature.
  *         (**) HSI_VALUE is a constant defined in stm32h7xx_hal.h file (default value
  *             64 MHz) but the real value may vary depending on the variations
  *             in voltage and temperature.
  *
  *         (***)HSE_VALUE is a constant defined in stm32h7xx_hal.h file (default value
  *              25 MHz), user has to ensure that HSE_VALUE is same as the real
  *              frequency of the crystal used. Otherwise, this function may
  *              have wrong result.
  *
  *         - The result of this function could be not correct when using fractional
  *           value for HSE crystal.
  * @param  None
  * @retval None
  */
void SystemCoreClockUpdate (void)
{
  uint32_t pllp, pllsource, pllm, pllfracen, hsivalue, tmp;
  uint32_t common_system_clock;
  float_t fracn1, pllvco;


  /* Get SYSCLK source -------------------------------------------------------*/

  switch (RCC->CFGR & RCC_CFGR_SWS)
  {
  case RCC_CFGR_SWS_HSI:  /* HSI used as system clock source */
    common_system_clock = (uint32_t) (HSI_VALUE >> ((RCC->CR & RCC_CR_HSIDIV)>> 3));
    break;

  case RCC_CFGR_SWS_CSI:  /* CSI used as system clock  source */
    common_system_clock = CSI_VALUE;
    break;

  case RCC_CFGR_SWS_HSE:  /* HSE used as system clock  source */
    common_system_clock = HSE_VALUE;
    break;

  case RCC_CFGR_SWS_PLL1:  /* PLL1 used as system clock  source */

    /* PLL_VCO = (HSE_VALUE or HSI_VALUE or CSI_VALUE/ PLLM) * PLLN
    SYSCLK = PLL_VCO / PLLR
    */
    pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
    pllm = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM1)>> 4)  ;
    pllfracen = ((RCC->PLLCFGR & RCC_PLLCFGR_PLL1FRACEN)>>RCC_PLLCFGR_PLL1FRACEN_Pos);
    fracn1 = (float_t)(uint32_t)(pllfracen* ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));

    if (pllm != 0U)
    {
      switch (pllsource)
      {
        case RCC_PLLCKSELR_PLLSRC_HSI:  /* HSI used as PLL clock source */

        hsivalue = (HSI_VALUE >> ((RCC->CR & RCC_CR_HSIDIV)>> 3)) ;
        pllvco = ( (float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );

        break;

        case RCC_PLLCKSELR_PLLSRC_CSI:  /* CSI used as PLL clock source */
          pllvco = ((float_t)CSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
        break;

        case RCC_PLLCKSELR_PLLSRC_HSE:  /* HSE used as PLL clock source */
          pllvco = ((float_t)HSE_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
        break;

      default:
          hsivalue = (HSI_VALUE >> ((RCC->CR & RCC_CR_HSIDIV)>> 3)) ;
          pllvco = ((float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
        break;
      }
      pllp = (((RCC->PLL1DIVR & RCC_PLL1DIVR_P1) >>9) + 1U ) ;
      common_system_clock =  (uint32_t)(float_t)(pllvco/(float_t)pllp);
    }
    else
    {
      common_system_clock = 0U;
    }
    break;

  default:
    common_system_clock = (uint32_t) (HSI_VALUE >> ((RCC->CR & RCC_CR_HSIDIV)>> 3));
    break;
  }

  /* Compute SystemClock frequency --------------------------------------------------*/
#if defined (RCC_D1CFGR_D1CPRE)
  tmp = D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos];

  /* common_system_clock frequency : CM7 CPU frequency  */
  common_system_clock >>= tmp;

  /* SystemD2Clock frequency : CM4 CPU, AXI and AHBs Clock frequency  */
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));

#else
  tmp = D1CorePrescTable[(RCC->CDCFGR1 & RCC_CDCFGR1_CDCPRE)>> RCC_CDCFGR1_CDCPRE_Pos];

  /* common_system_clock frequency : CM7 CPU frequency  */
  common_system_clock >>= tmp;

  /* SystemD2Clock frequency : AXI and AHBs Clock frequency  */
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->CDCFGR1 & RCC_CDCFGR1_HPRE)>> RCC_CDCFGR1_HPRE_Pos]) & 0x1FU));

#endif

#if defined(DUAL_CORE) && defined(CORE_CM4)
  SystemCoreClock = SystemD2Clock;
#else
  SystemCoreClock = common_system_clock;
#endif /* DUAL_CORE && CORE_CM4 */
}


/**
  * @}
  */

/**
  * @}
  */

/**
  * @}
  */
---- code end ----

